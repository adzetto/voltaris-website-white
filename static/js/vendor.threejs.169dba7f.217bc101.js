"use strict";(self.webpackChunkvoltaris_website=self.webpackChunkvoltaris_website||[]).push([[910],{1119:(e,t,n)=>{n.d(t,{OH:()=>S});var r=n(8168),o=n(9950),i=n(2880),s=n(7226),a=n(8290),l=n(3323),c=n(793),u=n(6630);const d={apartment:"lebombo_1k.hdr",city:"potsdamer_platz_1k.hdr",dawn:"kiara_1_dawn_1k.hdr",forest:"forest_slope_1k.hdr",lobby:"st_fagans_interior_1k.hdr",night:"dikhololo_night_1k.hdr",park:"rooitou_park_1k.hdr",studio:"studio_small_03_1k.hdr",sunset:"venice_sunset_1k.hdr",warehouse:"empty_warehouse_01_1k.hdr"},f=3e3,p=3001,h="https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/",m=e=>Array.isArray(e),g=["/px.png","/nx.png","/py.png","/ny.png","/pz.png","/nz.png"];function y(){let{files:e=g,path:t="",preset:n,encoding:r,extensions:a}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},l=null,c=!1;n&&(w(n),e=d[n],t=h),c=m(e);const{extension:u,isCubemap:y}=b(e);if(l=P(u),!l)throw new Error("useEnvironment: Unrecognized file extension: "+e);const x=(0,i.D)((e=>e.gl));(0,o.useLayoutEffect)((()=>{"webp"!==u&&"jpg"!==u&&"jpeg"!==u||x.domElement.addEventListener("webglcontextlost",(function(){i.H.clear(l,c?[e]:e)}),{once:!0})}),[e,x.domElement]);const v=(0,i.H)(l,c?[e]:e,(e=>{"webp"!==u&&"jpg"!==u&&"jpeg"!==u||e.setRenderer(x),null==e.setPath||e.setPath(t),a&&a(e)}));let B=c?v[0]:v;var A;"jpg"!==u&&"jpeg"!==u&&"webp"!==u||(B=null==(A=B.renderTarget)?void 0:A.texture);return B.mapping=y?s.hy7:s.wfO,"colorSpace"in B?B.colorSpace=(null!==r&&void 0!==r?r:y)?"srgb":"srgb-linear":B.encoding=(null!==r&&void 0!==r?r:y)?p:f,B}const x={files:g,path:"",preset:void 0,extensions:void 0};y.preload=e=>{const t={...x,...e};let{files:n,path:r=""}=t;const{preset:o,extensions:s}=t;o&&(w(o),n=d[o],r=h);const{extension:a}=b(n);if("webp"===a||"jpg"===a||"jpeg"===a)throw new Error("useEnvironment: Preloading gainmaps is not supported");const l=P(a);if(!l)throw new Error("useEnvironment: Unrecognized file extension: "+n);i.H.preload(l,m(n)?[n]:n,(e=>{null==e.setPath||e.setPath(r),s&&s(e)}))};const v={files:g,preset:void 0};function w(e){if(!(e in d))throw new Error("Preset must be one of: "+Object.keys(d).join(", "))}function b(e){var t;const n=m(e)&&6===e.length,r=m(e)&&3===e.length&&e.some((e=>e.endsWith("json"))),o=m(e)?e[0]:e;return{extension:n?"cube":r?"webp":o.startsWith("data:application/exr")?"exr":o.startsWith("data:application/hdr")?"hdr":o.startsWith("data:image/jpeg")?"jpg":null==(t=o.split(".").pop())||null==(t=t.split("?"))||null==(t=t.shift())?void 0:t.toLowerCase(),isCubemap:n,isGainmap:r}}function P(e){return"cube"===e?s.ScU:"hdr"===e?l.Y:"exr"===e?c.H:"jpg"===e||"jpeg"===e?u.pb:"webp"===e?u.j:null}y.clear=e=>{const t={...v,...e};let{files:n}=t;const{preset:r}=t;r&&(w(r),n=d[r]);const{extension:o}=b(n),s=P(o);if(!s)throw new Error("useEnvironment: Unrecognized file extension: "+n);i.H.clear(s,m(n)?[n]:n)};const B=e=>{return(t=e).current&&t.current.isScene?e.current:e;var t};function A(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};var s,a,l,c;o={backgroundBlurriness:0,backgroundIntensity:1,backgroundRotation:[0,0,0],environmentIntensity:1,environmentRotation:[0,0,0],...o};const u=B(t||n),d=u.background,f=u.environment,p={backgroundBlurriness:u.backgroundBlurriness,backgroundIntensity:u.backgroundIntensity,backgroundRotation:null!==(s=null==(a=u.backgroundRotation)||null==a.clone?void 0:a.clone())&&void 0!==s?s:[0,0,0],environmentIntensity:u.environmentIntensity,environmentRotation:null!==(l=null==(c=u.environmentRotation)||null==c.clone?void 0:c.clone())&&void 0!==l?l:[0,0,0]};return"only"!==e&&(u.environment=r),e&&(u.background=r),(0,i.k)(u,o),()=>{"only"!==e&&(u.environment=f),e&&(u.background=d),(0,i.k)(u,p)}}function T(e){let{scene:t,background:n=!1,map:r,...s}=e;const a=(0,i.D)((e=>e.scene));return o.useLayoutEffect((()=>{if(r)return A(n,t,a,r,s)})),null}function M(e){let{background:t=!1,scene:n,blur:r,backgroundBlurriness:s,backgroundIntensity:a,backgroundRotation:l,environmentIntensity:c,environmentRotation:u,...d}=e;const f=y(d),p=(0,i.D)((e=>e.scene));return o.useLayoutEffect((()=>A(t,n,p,f,{backgroundBlurriness:null!==r&&void 0!==r?r:s,backgroundIntensity:a,backgroundRotation:l,environmentIntensity:c,environmentRotation:u}))),o.useEffect((()=>()=>{f.dispose()}),[f]),null}function E(e){let{children:t,near:n=.1,far:r=1e3,resolution:a=256,frames:l=1,map:c,background:u=!1,blur:d,backgroundBlurriness:f,backgroundIntensity:p,backgroundRotation:h,environmentIntensity:m,environmentRotation:g,scene:y,files:x,path:v,preset:w,extensions:b}=e;const P=(0,i.D)((e=>e.gl)),B=(0,i.D)((e=>e.scene)),E=o.useRef(null),[I]=o.useState((()=>new s.Z58)),S=o.useMemo((()=>{const e=new s.o6l(a);return e.texture.type=s.ix0,e}),[a]);o.useEffect((()=>()=>{S.dispose()}),[S]),o.useLayoutEffect((()=>{if(1===l){const e=P.autoClear;P.autoClear=!0,E.current.update(P,I),P.autoClear=e}return A(u,y,B,S.texture,{backgroundBlurriness:null!==d&&void 0!==d?d:f,backgroundIntensity:p,backgroundRotation:h,environmentIntensity:m,environmentRotation:g})}),[t,I,S.texture,y,B,u,l,P]);let k=1;return(0,i.F)((()=>{if(l===1/0||k<l){const e=P.autoClear;P.autoClear=!0,E.current.update(P,I),P.autoClear=e,k++}})),o.createElement(o.Fragment,null,(0,i.h)(o.createElement(o.Fragment,null,t,o.createElement("cubeCamera",{ref:E,args:[n,r,S]}),x||w?o.createElement(M,{background:!0,files:x,preset:w,path:v,extensions:b}):c?o.createElement(T,{background:!0,map:c,extensions:b}):null),I))}function I(e){var t,n,s,l;const c=y(e),u=e.map||c;o.useMemo((()=>(0,i.e)({GroundProjectedEnvImpl:a.L})),[]),o.useEffect((()=>()=>{c.dispose()}),[c]);const d=o.useMemo((()=>[u]),[u]),f=null==(t=e.ground)?void 0:t.height,p=null==(n=e.ground)?void 0:n.radius,h=null!==(s=null==(l=e.ground)?void 0:l.scale)&&void 0!==s?s:1e3;return o.createElement(o.Fragment,null,o.createElement(T,(0,r.A)({},e,{map:u})),o.createElement("groundProjectedEnvImpl",{args:d,scale:h,height:f,radius:p}))}function S(e){return e.ground?o.createElement(I,e):e.map?o.createElement(T,e):e.children?o.createElement(E,e):o.createElement(M,e)}},1162:(e,t,n)=>{n.d(t,{n:()=>s});var r=n(9950),o=n(2880),i=n(7226);const s=r.forwardRef(((e,t)=>{let{children:n,enabled:s=!0,speed:a=1,rotationIntensity:l=1,floatIntensity:c=1,floatingRange:u=[-.1,.1],autoInvalidate:d=!1,...f}=e;const p=r.useRef(null);r.useImperativeHandle(t,(()=>p.current),[]);const h=r.useRef(1e4*Math.random());return(0,o.F)((e=>{var t,n;if(!s||0===a)return;d&&e.invalidate();const r=h.current+e.clock.elapsedTime;p.current.rotation.x=Math.cos(r/4*a)/8*l,p.current.rotation.y=Math.sin(r/4*a)/8*l,p.current.rotation.z=Math.sin(r/4*a)/20*l;let o=Math.sin(r/4*a)/10;o=i.cj9.mapLinear(o,-.1,.1,null!==(t=null==u?void 0:u[0])&&void 0!==t?t:-.1,null!==(n=null==u?void 0:u[1])&&void 0!==n?n:.1),p.current.position.y=o*c,p.current.updateMatrix()})),r.createElement("group",f,r.createElement("group",{ref:p,matrixAutoUpdate:!1},n))}))},1185:(e,t,n)=>{n.d(t,{n:()=>u});var r=n(8168),o=n(9950),i=n(7226),s=n(2880);const a=(()=>parseInt(i.sPf.replace(/\D+/g,"")))();class l extends i.BKk{constructor(){super({uniforms:{depth:{value:null},opacity:{value:1},attenuation:{value:2.5},anglePower:{value:12},spotPosition:{value:new i.Pq0(0,0,0)},lightColor:{value:new i.Q1f("white")},cameraNear:{value:0},cameraFar:{value:1},resolution:{value:new i.I9Y(0,0)}},transparent:!0,depthWrite:!1,vertexShader:"\n        varying vec3 vNormal;\n        varying float vViewZ;\n        varying float vIntensity;\n        uniform vec3 spotPosition;\n        uniform float attenuation;\n\n        #include <common>\n        #include <logdepthbuf_pars_vertex>\n\n        void main() {\n          // compute intensity\n          vNormal = normalize(normalMatrix * normal);\n          vec4 worldPosition = modelMatrix * vec4(position, 1);\n          vec4 viewPosition = viewMatrix * worldPosition;\n          vViewZ = viewPosition.z;\n\n          vIntensity = 1.0 - saturate(distance(worldPosition.xyz, spotPosition) / attenuation);\n\n          gl_Position = projectionMatrix * viewPosition;\n\n          #include <logdepthbuf_vertex>\n        }\n      ",fragmentShader:`\n        varying vec3 vNormal;\n        varying float vViewZ;\n        varying float vIntensity;\n\n        uniform vec3 lightColor;\n        uniform float anglePower;\n        uniform sampler2D depth;\n        uniform vec2 resolution;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float opacity;\n\n        #include <packing>\n        #include <logdepthbuf_pars_fragment>\n\n        float readDepth(sampler2D depthSampler, vec2 uv) {\n          float fragCoordZ = texture(depthSampler, uv).r;\n\n          // https://github.com/mrdoob/three.js/issues/23072\n          #ifdef USE_LOGDEPTHBUF\n            float viewZ = 1.0 - exp2(fragCoordZ * log(cameraFar + 1.0) / log(2.0));\n          #else\n            float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\n          #endif\n\n          return viewZ;\n        }\n\n        void main() {\n          #include <logdepthbuf_fragment>\n\n          vec3 normal = vec3(vNormal.x, vNormal.y, abs(vNormal.z));\n          float angleIntensity = pow(dot(normal, vec3(0, 0, 1)), anglePower);\n          float intensity = vIntensity * angleIntensity;\n\n          // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry\n          bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;\n          if (isSoft) {\n            vec2 uv = gl_FragCoord.xy / resolution;\n            intensity *= smoothstep(0.0, 1.0, vViewZ - readDepth(depth, uv));\n          }\n\n          gl_FragColor = vec4(lightColor, intensity * opacity);\n\n          #include <tonemapping_fragment>\n          #include <${a>=154?"colorspace_fragment":"encodings_fragment"}>\n        }\n      `})}}function c(e){let{opacity:t=1,radiusTop:n,radiusBottom:r,depthBuffer:a,color:c="white",distance:u=5,angle:d=.15,attenuation:f=5,anglePower:p=5}=e;const h=o.useRef(null),m=(0,s.D)((e=>e.size)),g=(0,s.D)((e=>e.camera)),y=(0,s.D)((e=>e.viewport.dpr)),[x]=o.useState((()=>new l)),[v]=o.useState((()=>new i.Pq0));n=void 0===n?.1:n,r=void 0===r?7*d:r,(0,s.F)((()=>{x.uniforms.spotPosition.value.copy(h.current.getWorldPosition(v)),h.current.lookAt(h.current.parent.target.getWorldPosition(v))}));const w=o.useMemo((()=>{const e=new i.Ho_(n,r,u,128,64,!0);return e.applyMatrix4((new i.kn4).makeTranslation(0,-u/2,0)),e.applyMatrix4((new i.kn4).makeRotationX(-Math.PI/2)),e}),[u,n,r]);return o.createElement(o.Fragment,null,o.createElement("mesh",{ref:h,geometry:w,raycast:()=>null},o.createElement("primitive",{object:x,attach:"material","uniforms-opacity-value":t,"uniforms-lightColor-value":c,"uniforms-attenuation-value":f,"uniforms-anglePower-value":p,"uniforms-depth-value":a,"uniforms-cameraNear-value":g.near,"uniforms-cameraFar-value":g.far,"uniforms-resolution-value":a?[m.width*y,m.height*y]:[0,0]})))}const u=o.forwardRef(((e,t)=>{let{opacity:n=1,radiusTop:i,radiusBottom:s,depthBuffer:a,color:l="white",distance:u=5,angle:d=.15,attenuation:f=5,anglePower:p=5,volumetric:h=!0,debug:m=!1,children:g,...y}=e;const x=o.useRef(null);return o.useImperativeHandle(t,(()=>x.current),[]),o.createElement("group",null,m&&x.current&&o.createElement("spotLightHelper",{args:[x.current]}),o.createElement("spotLight",(0,r.A)({ref:x,angle:d,color:l,distance:u,castShadow:!0},y),h&&o.createElement(c,{debug:m,opacity:n,radiusTop:i,radiusBottom:s,depthBuffer:a,color:l,distance:u,angle:d,attenuation:f,anglePower:p})),g&&o.cloneElement(g,{spotlightRef:x,debug:m}))}))},1878:(e,t,n)=>{n.d(t,{N:()=>a});var r=n(8168),o=n(2880),i=n(9950),s=n(5455);const a=i.forwardRef(((e,t)=>{let{makeDefault:n,camera:a,regress:l,domElement:c,enableDamping:u=!0,keyEvents:d=!1,onChange:f,onStart:p,onEnd:h,...m}=e;const g=(0,o.D)((e=>e.invalidate)),y=(0,o.D)((e=>e.camera)),x=(0,o.D)((e=>e.gl)),v=(0,o.D)((e=>e.events)),w=(0,o.D)((e=>e.setEvents)),b=(0,o.D)((e=>e.set)),P=(0,o.D)((e=>e.get)),B=(0,o.D)((e=>e.performance)),A=a||y,T=c||v.connected||x.domElement,M=i.useMemo((()=>new s.N(A)),[A]);return(0,o.F)((()=>{M.enabled&&M.update()}),-1),i.useEffect((()=>(d&&M.connect(!0===d?T:d),M.connect(T),()=>{M.dispose()})),[d,T,l,M,g]),i.useEffect((()=>{const e=e=>{g(),l&&B.regress(),f&&f(e)},t=e=>{p&&p(e)},n=e=>{h&&h(e)};return M.addEventListener("change",e),M.addEventListener("start",t),M.addEventListener("end",n),()=>{M.removeEventListener("start",t),M.removeEventListener("end",n),M.removeEventListener("change",e)}}),[f,p,h,M,g,w]),i.useEffect((()=>{if(n){const e=P().controls;return b({controls:M}),()=>b({controls:e})}}),[n,M]),i.createElement("primitive",(0,r.A)({ref:t,object:M,enableDamping:u},m))}))},2182:(e,t,n)=>{n.d(t,{u:()=>l});var r=n(8168),o=n(9950),i=n(2880),s=n(7226);function a(e,t,n){const r=(0,i.D)((e=>e.size)),a=(0,i.D)((e=>e.viewport)),l="number"===typeof e?e:r.width*a.dpr,c="number"===typeof t?t:r.height*a.dpr,u=("number"===typeof e?n:e)||{},{samples:d=0,depth:f,...p}=u,h=o.useMemo((()=>{const e=new s.nWS(l,c,{minFilter:s.k6q,magFilter:s.k6q,type:s.ix0,...p});return f&&(e.depthTexture=new s.VCu(l,c,s.RQf)),e.samples=d,e}),[]);return o.useLayoutEffect((()=>{h.setSize(l,c),d&&(h.samples=d)}),[d,h,l,c]),o.useEffect((()=>()=>h.dispose()),[]),h}const l=o.forwardRef(((e,t)=>{let{envMap:n,resolution:s=256,frames:l=1/0,makeDefault:c,children:u,...d}=e;const f=(0,i.D)((e=>{let{set:t}=e;return t})),p=(0,i.D)((e=>{let{camera:t}=e;return t})),h=(0,i.D)((e=>{let{size:t}=e;return t})),m=o.useRef(null);o.useImperativeHandle(t,(()=>m.current),[]);const g=o.useRef(null),y=a(s);o.useLayoutEffect((()=>{d.manual||(m.current.aspect=h.width/h.height)}),[h,d]),o.useLayoutEffect((()=>{m.current.updateProjectionMatrix()}));let x=0,v=null;const w="function"===typeof u;return(0,i.F)((e=>{w&&(l===1/0||x<l)&&(g.current.visible=!1,e.gl.setRenderTarget(y),v=e.scene.background,n&&(e.scene.background=n),e.gl.render(e.scene,m.current),e.scene.background=v,e.gl.setRenderTarget(null),g.current.visible=!0,x++)})),o.useLayoutEffect((()=>{if(c){const e=p;return f((()=>({camera:m.current}))),()=>f((()=>({camera:e})))}}),[m,c,f]),o.createElement(o.Fragment,null,o.createElement("perspectiveCamera",(0,r.A)({ref:m},d),!w&&u),o.createElement("group",{ref:g},w&&u(y.texture)))}))},2342:(e,t,n)=>{n.d(t,{E:()=>x});var r=n(8168),o=n(9950),i=n(1352),s=n(7226),a=n(2880);const l=new s.Pq0,c=new s.Pq0,u=new s.Pq0,d=new s.I9Y;function f(e,t,n){const r=l.setFromMatrixPosition(e.matrixWorld);r.project(t);const o=n.width/2,i=n.height/2;return[r.x*o+o,-r.y*i+i]}const p=e=>Math.abs(e)<1e-10?0:e;function h(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",r="matrix3d(";for(let o=0;16!==o;o++)r+=p(t[o]*e.elements[o])+(15!==o?",":")");return n+r}const m=(g=[1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1],e=>h(e,g));var g;const y=(e,t)=>{return h(e,[1/(n=t),1/n,1/n,1,-1/n,-1/n,-1/n,-1,1/n,1/n,1/n,1,1,1,1,1],"translate(-50%,-50%)");var n};const x=o.forwardRef(((e,t)=>{let{children:n,eps:h=.001,style:g,className:x,prepend:v,center:w,fullscreen:b,portal:P,distanceFactor:B,sprite:A=!1,transform:T=!1,occlude:M,onOcclude:E,castShadow:I,receiveShadow:S,material:k,geometry:_,zIndexRange:F=[16777271,0],calculatePosition:q=f,as:R="div",wrapperClass:U,pointerEvents:z="auto",...D}=e;const{gl:C,camera:N,scene:L,size:j,raycaster:H,events:W,viewport:Z}=(0,a.D)(),[V]=o.useState((()=>document.createElement(R))),Y=o.useRef(),O=o.useRef(null),$=o.useRef(0),X=o.useRef([0,0]),G=o.useRef(null),K=o.useRef(null),Q=(null==P?void 0:P.current)||W.connected||C.domElement.parentNode,J=o.useRef(null),ee=o.useRef(!1),te=o.useMemo((()=>M&&"blending"!==M||Array.isArray(M)&&M.length&&function(e){return e&&"object"===typeof e&&"current"in e}(M[0])),[M]);o.useLayoutEffect((()=>{const e=C.domElement;M&&"blending"===M?(e.style.zIndex=`${Math.floor(F[0]/2)}`,e.style.position="absolute",e.style.pointerEvents="none"):(e.style.zIndex=null,e.style.position=null,e.style.pointerEvents=null)}),[M]),o.useLayoutEffect((()=>{if(O.current){const e=Y.current=i.createRoot(V);if(L.updateMatrixWorld(),T)V.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const e=q(O.current,N,j);V.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${e[0]}px,${e[1]}px,0);transform-origin:0 0;`}return Q&&(v?Q.prepend(V):Q.appendChild(V)),()=>{Q&&Q.removeChild(V),e.unmount()}}}),[Q,T]),o.useLayoutEffect((()=>{U&&(V.className=U)}),[U]);const ne=o.useMemo((()=>T?{position:"absolute",top:0,left:0,width:j.width,height:j.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:w?"translate3d(-50%,-50%,0)":"none",...b&&{top:-j.height/2,left:-j.width/2,width:j.width,height:j.height},...g}),[g,w,b,j,T]),re=o.useMemo((()=>({position:"absolute",pointerEvents:z})),[z]);o.useLayoutEffect((()=>{var e,r;(ee.current=!1,T)?null==(e=Y.current)||e.render(o.createElement("div",{ref:G,style:ne},o.createElement("div",{ref:K,style:re},o.createElement("div",{ref:t,className:x,style:g,children:n})))):null==(r=Y.current)||r.render(o.createElement("div",{ref:t,style:ne,className:x,children:n}))}));const oe=o.useRef(!0);(0,a.F)((e=>{if(O.current){N.updateMatrixWorld(),O.current.updateWorldMatrix(!0,!1);const e=T?X.current:q(O.current,N,j);if(T||Math.abs($.current-N.zoom)>h||Math.abs(X.current[0]-e[0])>h||Math.abs(X.current[1]-e[1])>h){const t=function(e,t){const n=l.setFromMatrixPosition(e.matrixWorld),r=c.setFromMatrixPosition(t.matrixWorld),o=n.sub(r),i=t.getWorldDirection(u);return o.angleTo(i)>Math.PI/2}(O.current,N);let n=!1;te&&(Array.isArray(M)?n=M.map((e=>e.current)):"blending"!==M&&(n=[L]));const r=oe.current;if(n){const e=function(e,t,n,r){const o=l.setFromMatrixPosition(e.matrixWorld),i=o.clone();i.project(t),d.set(i.x,i.y),n.setFromCamera(d,t);const s=n.intersectObjects(r,!0);if(s.length){const e=s[0].distance;return o.distanceTo(n.ray.origin)<e}return!0}(O.current,N,H,n);oe.current=e&&!t}else oe.current=!t;r!==oe.current&&(E?E(!oe.current):V.style.display=oe.current?"block":"none");const o=Math.floor(F[0]/2),i=M?te?[F[0],o]:[o-1,0]:F;if(V.style.zIndex=`${function(e,t,n){if(t instanceof s.ubm||t instanceof s.qUd){const r=l.setFromMatrixPosition(e.matrixWorld),o=c.setFromMatrixPosition(t.matrixWorld),i=r.distanceTo(o),s=(n[1]-n[0])/(t.far-t.near),a=n[1]-s*t.far;return Math.round(s*i+a)}}(O.current,N,i)}`,T){const[e,t]=[j.width/2,j.height/2],n=N.projectionMatrix.elements[5]*t,{isOrthographicCamera:r,top:o,left:i,bottom:s,right:a}=N,l=m(N.matrixWorldInverse),c=r?`scale(${n})translate(${p(-(a+i)/2)}px,${p((o+s)/2)}px)`:`translateZ(${n}px)`;let u=O.current.matrixWorld;A&&(u=N.matrixWorldInverse.clone().transpose().copyPosition(u).scale(O.current.scale),u.elements[3]=u.elements[7]=u.elements[11]=0,u.elements[15]=1),V.style.width=j.width+"px",V.style.height=j.height+"px",V.style.perspective=r?"":`${n}px`,G.current&&K.current&&(G.current.style.transform=`${c}${l}translate(${e}px,${t}px)`,K.current.style.transform=y(u,1/((B||10)/400)))}else{const t=void 0===B?1:function(e,t){if(t instanceof s.qUd)return t.zoom;if(t instanceof s.ubm){const n=l.setFromMatrixPosition(e.matrixWorld),r=c.setFromMatrixPosition(t.matrixWorld),o=t.fov*Math.PI/180,i=n.distanceTo(r);return 1/(2*Math.tan(o/2)*i)}return 1}(O.current,N)*B;V.style.transform=`translate3d(${e[0]}px,${e[1]}px,0) scale(${t})`}X.current=e,$.current=N.zoom}}if(!te&&J.current&&!ee.current)if(T){if(G.current){const e=G.current.children[0];if(null!=e&&e.clientWidth&&null!=e&&e.clientHeight){const{isOrthographicCamera:t}=N;if(t||_)D.scale&&(Array.isArray(D.scale)?D.scale instanceof s.Pq0?J.current.scale.copy(D.scale.clone().divideScalar(1)):J.current.scale.set(1/D.scale[0],1/D.scale[1],1/D.scale[2]):J.current.scale.setScalar(1/D.scale));else{const t=(B||10)/400,n=e.clientWidth*t,r=e.clientHeight*t;J.current.scale.set(n,r,1)}ee.current=!0}}}else{const t=V.children[0];if(null!=t&&t.clientWidth&&null!=t&&t.clientHeight){const e=1/Z.factor,n=t.clientWidth*e,r=t.clientHeight*e;J.current.scale.set(n,r,1),ee.current=!0}J.current.lookAt(e.camera.position)}}));const ie=o.useMemo((()=>({vertexShader:T?void 0:'\n          /*\n            This shader is from the THREE\'s SpriteMaterial.\n            We need to turn the backing plane into a Sprite\n            (make it always face the camera) if "transfrom"\n            is false.\n          */\n          #include <common>\n\n          void main() {\n            vec2 center = vec2(0., 1.);\n            float rotation = 0.0;\n\n            // This is somewhat arbitrary, but it seems to work well\n            // Need to figure out how to derive this dynamically if it even matters\n            float size = 0.03;\n\n            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n            vec2 scale;\n            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n            bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n            if ( isPerspective ) scale *= - mvPosition.z;\n\n            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;\n            vec2 rotatedPosition;\n            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n            mvPosition.xy += rotatedPosition;\n\n            gl_Position = projectionMatrix * mvPosition;\n          }\n      ',fragmentShader:"\n        void main() {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      "})),[T]);return o.createElement("group",(0,r.A)({},D,{ref:O}),M&&!te&&o.createElement("mesh",{castShadow:I,receiveShadow:S,ref:J},_||o.createElement("planeGeometry",null),k||o.createElement("shaderMaterial",{side:s.$EB,vertexShader:ie.vertexShader,fragmentShader:ie.fragmentShader})))}))},5786:(e,t,n)=>{n.d(t,{X:()=>i});var r=n(9950),o=n(2880);function i(){const e=(0,o.D)((e=>e.gl));return(0,r.useEffect)((()=>(e.shadowMap.autoUpdate=!1,e.shadowMap.needsUpdate=!0,()=>{e.shadowMap.autoUpdate=e.shadowMap.needsUpdate=!0})),[e.shadowMap]),null}},6739:(e,t,n)=>{n.d(t,{Z:()=>Yt});var r=n(8168),o=n(2880),i=n(9950),s=n(7226);const a=2,l=1.25,c=65535,u=Math.pow(2,-24),d=Symbol("SKIP_GENERATION");function f(e,t,n){return null===e?null:(e.point.applyMatrix4(t.matrixWorld),e.distance=e.point.distanceTo(n.ray.origin),e.object=t,e)}function p(e){return function(e){return e.index?e.index.count:e.attributes.position.count}(e)/3}function h(e,t){if(!e.index){const n=e.attributes.position.count,r=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ArrayBuffer;return e>65535?new Uint32Array(new t(4*e)):new Uint16Array(new t(2*e))}(n,t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);e.setIndex(new s.THS(r,1));for(let e=0;e<n;e++)r[e]=e}}function m(e,t){const n=p(e),r=t||e.drawRange,o=r.start/3,i=(r.start+r.count)/3,s=Math.max(0,o),a=Math.min(n,i)-s;return[{offset:Math.floor(s),count:Math.floor(a)}]}function g(e,t){if(!e.groups||!e.groups.length)return m(e,t);const n=[],r=new Set,o=t||e.drawRange,i=o.start/3,s=(o.start+o.count)/3;for(const l of e.groups){const e=l.start/3,t=(l.start+l.count)/3;r.add(Math.max(i,e)),r.add(Math.min(s,t))}const a=Array.from(r.values()).sort(((e,t)=>e-t));for(let l=0;l<a.length-1;l++){const e=a[l],t=a[l+1];n.push({offset:Math.floor(e),count:Math.floor(t-e)})}return n}function y(e,t,n,r,o){let i=1/0,s=1/0,a=1/0,l=-1/0,c=-1/0,u=-1/0,d=1/0,f=1/0,p=1/0,h=-1/0,m=-1/0,g=-1/0;for(let y=6*t,x=6*(t+n);y<x;y+=6){const t=e[y+0],n=e[y+1],r=t-n,o=t+n;r<i&&(i=r),o>l&&(l=o),t<d&&(d=t),t>h&&(h=t);const x=e[y+2],v=e[y+3],w=x-v,b=x+v;w<s&&(s=w),b>c&&(c=b),x<f&&(f=x),x>m&&(m=x);const P=e[y+4],B=e[y+5],A=P-B,T=P+B;A<a&&(a=A),T>u&&(u=T),P<p&&(p=P),P>g&&(g=P)}r[0]=i,r[1]=s,r[2]=a,r[3]=l,r[4]=c,r[5]=u,o[0]=d,o[1]=f,o[2]=p,o[3]=h,o[4]=m,o[5]=g}function x(e,t,n){return n.min.x=t[e],n.min.y=t[e+1],n.min.z=t[e+2],n.max.x=t[e+3],n.max.y=t[e+4],n.max.z=t[e+5],n}function v(e){let t=-1,n=-1/0;for(let r=0;r<3;r++){const o=e[r+3]-e[r];o>n&&(n=o,t=r)}return t}function w(e,t){t.set(e)}function b(e,t,n){let r,o;for(let i=0;i<3;i++){const s=i+3;r=e[i],o=t[i],n[i]=r<o?r:o,r=e[s],o=t[s],n[s]=r>o?r:o}}function P(e,t,n){for(let r=0;r<3;r++){const o=t[e+2*r],i=t[e+2*r+1],s=o-i,a=o+i;s<n[r]&&(n[r]=s),a>n[r+3]&&(n[r+3]=a)}}function B(e){const t=e[3]-e[0],n=e[4]-e[1],r=e[5]-e[2];return 2*(t*n+n*r+r*t)}const A=32,T=(e,t)=>e.candidate-t.candidate,M=new Array(A).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),E=new Float32Array(6);class I{constructor(){this.boundingData=new Float32Array(6)}}function S(e,t,n,r,o,i){let s=r,a=r+o-1;const l=i.pos,c=2*i.axis;for(;;){for(;s<=a&&n[6*s+c]<l;)s++;for(;s<=a&&n[6*a+c]>=l;)a--;if(!(s<a))return s;for(let e=0;e<3;e++){let n=t[3*s+e];t[3*s+e]=t[3*a+e],t[3*a+e]=n}for(let e=0;e<6;e++){let t=n[6*s+e];n[6*s+e]=n[6*a+e],n[6*a+e]=t}s++,a--}}function k(e,t,n,r,o,i){let s=r,a=r+o-1;const l=i.pos,c=2*i.axis;for(;;){for(;s<=a&&n[6*s+c]<l;)s++;for(;s<=a&&n[6*a+c]>=l;)a--;if(!(s<a))return s;{let t=e[s];e[s]=e[a],e[a]=t;for(let e=0;e<6;e++){let t=n[6*s+e];n[6*s+e]=n[6*a+e],n[6*a+e]=t}s++,a--}}}function _(e,t){return 65535===t[e+15]}function F(e,t){return t[e+6]}function q(e,t){return t[e+14]}function R(e){return e+8}function U(e,t){return t[e+6]}function z(e,t){return t[e+7]}let D,C,N,L;const j=Math.pow(2,32);function H(e){return"count"in e?1:1+H(e.left)+H(e.right)}function W(e,t,n){return D=new Float32Array(n),C=new Uint32Array(n),N=new Uint16Array(n),L=new Uint8Array(n),Z(e,t)}function Z(e,t){const n=e/4,r=e/2,o="count"in t,i=t.boundingData;for(let s=0;s<6;s++)D[n+s]=i[s];if(o){if(t.buffer){const r=t.buffer;L.set(new Uint8Array(r),e);for(let t=e,o=e+r.byteLength;t<o;t+=32){_(t/2,N)||(C[t/4+6]+=n)}return e+r.byteLength}{const o=t.offset,i=t.count;return C[n+6]=o,N[r+14]=i,N[r+15]=c,e+32}}{const r=t.left,o=t.right,i=t.splitAxis;let s;if(s=Z(e+32,r),s/4>j)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return C[n+6]=s/4,s=Z(s,o),C[n+7]=i,s}}function V(e,t,n,r,o){const{maxDepth:i,verbose:s,maxLeafTris:c,strategy:u,onProgress:d,indirect:f}=o,h=e._indirectBuffer,m=e.geometry,g=m.index?m.index.array:null,x=f?k:S,_=p(m),F=new Float32Array(6);let q=!1;const R=new I;return y(t,n,r,R.boundingData,F),function e(n,r,o){let d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,f=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;!q&&f>=i&&(q=!0,s&&(console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`),console.warn(m)));if(o<=c||f>=i)return U(r+o),n.offset=r,n.count=o,n;const p=function(e,t,n,r,o,i){let s=-1,c=0;if(0===i)s=v(t),-1!==s&&(c=(t[s]+t[s+3])/2);else if(1===i)s=v(e),-1!==s&&(c=function(e,t,n,r){let o=0;for(let i=t,s=t+n;i<s;i++)o+=e[6*i+2*r];return o/n}(n,r,o,s));else if(i===a){const i=B(e);let a=l*o;const u=6*r,d=6*(r+o);for(let e=0;e<3;e++){const r=t[e],f=(t[e+3]-r)/A;if(o<8){const t=[...M];t.length=o;let r=0;for(let o=u;o<d;o+=6,r++){const i=t[r];i.candidate=n[o+2*e],i.count=0;const{bounds:s,leftCacheBounds:a,rightCacheBounds:l}=i;for(let e=0;e<3;e++)l[e]=1/0,l[e+3]=-1/0,a[e]=1/0,a[e+3]=-1/0,s[e]=1/0,s[e+3]=-1/0;P(o,n,s)}t.sort(T);let f=o;for(let e=0;e<f;e++){const n=t[e];for(;e+1<f&&t[e+1].candidate===n.candidate;)t.splice(e+1,1),f--}for(let o=u;o<d;o+=6){const r=n[o+2*e];for(let e=0;e<f;e++){const i=t[e];r>=i.candidate?P(o,n,i.rightCacheBounds):(P(o,n,i.leftCacheBounds),i.count++)}}for(let n=0;n<f;n++){const r=t[n],u=r.count,d=o-r.count,f=r.leftCacheBounds,p=r.rightCacheBounds;let h=0;0!==u&&(h=B(f)/i);let m=0;0!==d&&(m=B(p)/i);const g=1+l*(h*u+m*d);g<a&&(s=e,a=g,c=r.candidate)}}else{for(let e=0;e<A;e++){const t=M[e];t.count=0,t.candidate=r+f+e*f;const n=t.bounds;for(let e=0;e<3;e++)n[e]=1/0,n[e+3]=-1/0}for(let o=u;o<d;o+=6){let t=~~((n[o+2*e]-r)/f);t>=A&&(t=31);const i=M[t];i.count++,P(o,n,i.bounds)}const t=M[31];w(t.bounds,t.rightCacheBounds);for(let e=30;e>=0;e--){const t=M[e],n=M[e+1];b(t.bounds,n.rightCacheBounds,t.rightCacheBounds)}let p=0;for(let n=0;n<31;n++){const t=M[n],r=t.count,u=t.bounds,d=M[n+1].rightCacheBounds;0!==r&&(0===p?w(u,E):b(u,E,E)),p+=r;let f=0,h=0;0!==p&&(f=B(E)/i);const m=o-p;0!==m&&(h=B(d)/i);const g=1+l*(f*p+h*m);g<a&&(s=e,a=g,c=t.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${i} used.`);return{axis:s,pos:c}}(n.boundingData,d,t,r,o,u);if(-1===p.axis)return U(r+o),n.offset=r,n.count=o,n;const S=x(h,g,t,r,o,p);if(S===r||S===r+o)U(r+o),n.offset=r,n.count=o;else{n.splitAxis=p.axis;const i=new I,s=r,a=S-r;n.left=i,y(t,s,a,i.boundingData,F),e(i,s,a,F,f+1);const l=new I,c=S,u=o-a;n.right=l,y(t,c,u,l.boundingData,F),e(l,c,u,F,f+1)}return n}(R,n,r,F),R;function U(e){d&&d(e/_)}}function Y(e,t){const n=e.geometry;t.indirect&&(e._indirectBuffer=function(e,t){const n=(e.index?e.index.count:e.attributes.position.count)/3,r=n>65536,o=r?4:2,i=t?new SharedArrayBuffer(n*o):new ArrayBuffer(n*o),s=r?new Uint32Array(i):new Uint16Array(i);for(let a=0,l=s.length;a<l;a++)s[a]=a;return s}(n,t.useSharedArrayBuffer),function(e,t){const n=p(e),r=g(e,t).sort(((e,t)=>e.offset-t.offset)),o=r[r.length-1];o.count=Math.min(n-o.offset,o.count);let i=0;return r.forEach((e=>{let{count:t}=e;return i+=t})),n!==i}(n,t.range)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),e._indirectBuffer||h(n,t);const r=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,o=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o=e.attributes.position,i=e.index?e.index.array:null,s=p(e),a=o.normalized;let l;null===t?(l=new Float32Array(6*s*4),n=0,r=s):(l=t,n=n||0,r=r||s);const c=o.array,d=o.offset||0;let f=3;o.isInterleavedBufferAttribute&&(f=o.data.stride);const h=["getX","getY","getZ"];for(let p=n;p<n+r;p++){const e=3*p,t=6*p;let n=e+0,r=e+1,s=e+2;i&&(n=i[n],r=i[r],s=i[s]),a||(n=n*f+d,r=r*f+d,s=s*f+d);for(let i=0;i<3;i++){let e,d,f;a?(e=o[h[i]](n),d=o[h[i]](r),f=o[h[i]](s)):(e=c[n+i],d=c[r+i],f=c[s+i]);let p=e;d<p&&(p=d),f<p&&(p=f);let m=e;d>m&&(m=d),f>m&&(m=f);const g=(m-p)/2,y=2*i;l[t+y+0]=p+g,l[t+y+1]=g+(Math.abs(p)+g)*u}}return l}(n),i=t.indirect?m(n,t.range):g(n,t.range);e._roots=i.map((n=>{const i=V(e,o,n.offset,n.count,t),s=H(i),a=new r(32*s);return W(0,i,a),a}))}class O{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(e,t){let n=1/0,r=-1/0;for(let o=0,i=e.length;o<i;o++){const i=e[o][t];n=i<n?i:n,r=i>r?i:r}this.min=n,this.max=r}setFromPoints(e,t){let n=1/0,r=-1/0;for(let o=0,i=t.length;o<i;o++){const i=t[o],s=e.dot(i);n=s<n?s:n,r=s>r?s:r}this.min=n,this.max=r}isSeparated(e){return this.min>e.max||e.min>this.max}}O.prototype.setFromBox=function(){const e=new s.Pq0;return function(t,n){const r=n.min,o=n.max;let i=1/0,s=-1/0;for(let a=0;a<=1;a++)for(let n=0;n<=1;n++)for(let l=0;l<=1;l++){e.x=r.x*a+o.x*(1-a),e.y=r.y*n+o.y*(1-n),e.z=r.z*l+o.z*(1-l);const c=t.dot(e);i=Math.min(c,i),s=Math.max(c,s)}this.min=i,this.max=s}}();!function(){const e=new O}();const $=function(){const e=new s.Pq0,t=new s.Pq0,n=new s.Pq0;return function(r,o,i){const s=r.start,a=e,l=o.start,c=t;n.subVectors(s,l),e.subVectors(r.end,r.start),t.subVectors(o.end,o.start);const u=n.dot(c),d=c.dot(a),f=c.dot(c),p=n.dot(a),h=a.dot(a)*f-d*d;let m,g;m=0!==h?(u*d-p*f)/h:0,g=(u+m*d)/f,i.x=m,i.y=g}}(),X=function(){const e=new s.I9Y,t=new s.Pq0,n=new s.Pq0;return function(r,o,i,s){$(r,o,e);let a=e.x,l=e.y;if(a>=0&&a<=1&&l>=0&&l<=1)return r.at(a,i),void o.at(l,s);if(a>=0&&a<=1)return l<0?o.at(0,s):o.at(1,s),void r.closestPointToPoint(s,!0,i);if(l>=0&&l<=1)return a<0?r.at(0,i):r.at(1,i),void o.closestPointToPoint(i,!0,s);{let e,c;e=a<0?r.start:r.end,c=l<0?o.start:o.end;const u=t,d=n;return r.closestPointToPoint(c,!0,t),o.closestPointToPoint(e,!0,n),u.distanceToSquared(c)<=d.distanceToSquared(e)?(i.copy(u),void s.copy(c)):(i.copy(e),void s.copy(d))}}}(),G=function(){const e=new s.Pq0,t=new s.Pq0,n=new s.Zcv,r=new s.cZY;return function(o,i){const{radius:s,center:a}=o,{a:l,b:c,c:u}=i;r.start=l,r.end=c;if(r.closestPointToPoint(a,!0,e).distanceTo(a)<=s)return!0;r.start=l,r.end=u;if(r.closestPointToPoint(a,!0,e).distanceTo(a)<=s)return!0;r.start=c,r.end=u;if(r.closestPointToPoint(a,!0,e).distanceTo(a)<=s)return!0;const d=i.getPlane(n);if(Math.abs(d.distanceToPoint(a))<=s){const e=d.projectPoint(a,t);if(i.containsPoint(e))return!0}return!1}}();function K(e){return Math.abs(e)<1e-15}class Q extends s.lMl{constructor(){super(...arguments),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new s.Pq0)),this.satBounds=new Array(4).fill().map((()=>new O)),this.points=[this.a,this.b,this.c],this.sphere=new s.iyt,this.plane=new s.Zcv,this.needsUpdate=!0}intersectsSphere(e){return G(e,this)}update(){const e=this.a,t=this.b,n=this.c,r=this.points,o=this.satAxes,i=this.satBounds,s=o[0],a=i[0];this.getNormal(s),a.setFromPoints(s,r);const l=o[1],c=i[1];l.subVectors(e,t),c.setFromPoints(l,r);const u=o[2],d=i[2];u.subVectors(t,n),d.setFromPoints(u,r);const f=o[3],p=i[3];f.subVectors(n,e),p.setFromPoints(f,r),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(s,e),this.needsUpdate=!1}}Q.prototype.closestPointToSegment=function(){const e=new s.Pq0,t=new s.Pq0,n=new s.cZY;return function(r){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const{start:s,end:a}=r,l=this.points;let c,u=1/0;for(let d=0;d<3;d++){const s=(d+1)%3;n.start.copy(l[d]),n.end.copy(l[s]),X(n,r,e,t),c=e.distanceToSquared(t),c<u&&(u=c,o&&o.copy(e),i&&i.copy(t))}return this.closestPointToPoint(s,e),c=s.distanceToSquared(e),c<u&&(u=c,o&&o.copy(e),i&&i.copy(s)),this.closestPointToPoint(a,e),c=a.distanceToSquared(e),c<u&&(u=c,o&&o.copy(e),i&&i.copy(a)),Math.sqrt(u)}}(),Q.prototype.intersectsTriangle=function(){const e=new Q,t=new Array(3),n=new Array(3),r=new O,o=new O,i=new s.Pq0,a=new s.Pq0,l=new s.Pq0,c=new s.Pq0,u=new s.Pq0,d=new s.cZY,f=new s.cZY,p=new s.cZY,h=new s.Pq0;function m(e,t,n){const r=e.points;let o=0,i=-1;for(let s=0;s<3;s++){const{start:e,end:l}=d;e.copy(r[s]),l.copy(r[(s+1)%3]),d.delta(a);const c=K(t.distanceToPoint(e));if(K(t.normal.dot(a))&&c){n.copy(d),o=2;break}const u=t.intersectLine(d,h);if(!u&&c&&h.copy(e),(u||c)&&!K(h.distanceTo(l))){if(o<=1){(1===o?n.start:n.end).copy(h),c&&(i=o)}else if(o>=2){(1===i?n.start:n.end).copy(h),o=2;break}if(o++,2===o&&-1===i)break}}return o}return function(s){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,d=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this.needsUpdate&&this.update(),s.isExtendedTriangle?s.needsUpdate&&s.update():(e.copy(s),e.update(),s=e);const h=this.plane,g=s.plane;if(Math.abs(h.normal.dot(g.normal))>1-1e-10){const e=this.satBounds,l=this.satAxes;n[0]=s.a,n[1]=s.b,n[2]=s.c;for(let t=0;t<4;t++){const o=e[t],i=l[t];if(r.setFromPoints(i,n),o.isSeparated(r))return!1}const c=s.satBounds,u=s.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let n=0;n<4;n++){const e=c[n],o=u[n];if(r.setFromPoints(o,t),e.isSeparated(r))return!1}for(let s=0;s<4;s++){const e=l[s];for(let s=0;s<4;s++){const a=u[s];if(i.crossVectors(e,a),r.setFromPoints(i,t),o.setFromPoints(i,n),r.isSeparated(o))return!1}}return a&&(d||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),a.start.set(0,0,0),a.end.set(0,0,0)),!0}{const e=m(this,g,f);if(1===e&&s.containsPoint(f.end))return a&&(a.start.copy(f.end),a.end.copy(f.end)),!0;if(2!==e)return!1;const t=m(s,h,p);if(1===t&&this.containsPoint(p.end))return a&&(a.start.copy(p.end),a.end.copy(p.end)),!0;if(2!==t)return!1;if(f.delta(l),p.delta(c),l.dot(c)<0){let e=p.start;p.start=p.end,p.end=e}const n=f.start.dot(l),r=f.end.dot(l),o=p.start.dot(l),i=p.end.dot(l);return(n===i||o===r||r<o!==n<i)&&(a&&(u.subVectors(f.start,p.start),u.dot(l)>0?a.start.copy(f.start):a.start.copy(p.start),u.subVectors(f.end,p.end),u.dot(l)<0?a.end.copy(f.end):a.end.copy(p.end)),!0)}}}(),Q.prototype.distanceToPoint=function(){const e=new s.Pq0;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}(),Q.prototype.distanceToTriangle=function(){const e=new s.Pq0,t=new s.Pq0,n=["a","b","c"],r=new s.cZY,o=new s.cZY;return function(i){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const l=s||a?r:null;if(this.intersectsTriangle(i,l))return(s||a)&&(s&&l.getCenter(s),a&&l.getCenter(a)),0;let c=1/0;for(let t=0;t<3;t++){let r;const o=n[t],l=i[o];this.closestPointToPoint(l,e),r=l.distanceToSquared(e),r<c&&(c=r,s&&s.copy(e),a&&a.copy(l));const u=this[o];i.closestPointToPoint(u,e),r=u.distanceToSquared(e),r<c&&(c=r,s&&s.copy(u),a&&a.copy(e))}for(let u=0;u<3;u++){const l=n[u],d=n[(u+1)%3];r.set(this[l],this[d]);for(let u=0;u<3;u++){const l=n[u],d=n[(u+1)%3];o.set(i[l],i[d]),X(r,o,e,t);const f=e.distanceToSquared(t);f<c&&(c=f,s&&s.copy(e),a&&a.copy(t))}}return Math.sqrt(c)}}();class J{constructor(e,t,n){this.isOrientedBox=!0,this.min=new s.Pq0,this.max=new s.Pq0,this.matrix=new s.kn4,this.invMatrix=new s.kn4,this.points=new Array(8).fill().map((()=>new s.Pq0)),this.satAxes=new Array(3).fill().map((()=>new s.Pq0)),this.satBounds=new Array(3).fill().map((()=>new O)),this.alignedSatBounds=new Array(3).fill().map((()=>new O)),this.needsUpdate=!1,e&&this.min.copy(e),t&&this.max.copy(t),n&&this.matrix.copy(n)}set(e,t,n){this.min.copy(e),this.max.copy(t),this.matrix.copy(n),this.needsUpdate=!0}copy(e){this.min.copy(e.min),this.max.copy(e.max),this.matrix.copy(e.matrix),this.needsUpdate=!0}}J.prototype.update=function(){const e=this.matrix,t=this.min,n=this.max,r=this.points;for(let l=0;l<=1;l++)for(let o=0;o<=1;o++)for(let i=0;i<=1;i++){const s=r[1*l|2*o|4*i];s.x=l?n.x:t.x,s.y=o?n.y:t.y,s.z=i?n.z:t.z,s.applyMatrix4(e)}const o=this.satBounds,i=this.satAxes,s=r[0];for(let l=0;l<3;l++){const e=i[l],t=o[l],n=r[1<<l];e.subVectors(s,n),t.setFromPoints(e,r)}const a=this.alignedSatBounds;a[0].setFromPointsField(r,"x"),a[1].setFromPointsField(r,"y"),a[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},J.prototype.intersectsBox=function(){const e=new O;return function(t){this.needsUpdate&&this.update();const n=t.min,r=t.max,o=this.satBounds,i=this.satAxes,s=this.alignedSatBounds;if(e.min=n.x,e.max=r.x,s[0].isSeparated(e))return!1;if(e.min=n.y,e.max=r.y,s[1].isSeparated(e))return!1;if(e.min=n.z,e.max=r.z,s[2].isSeparated(e))return!1;for(let a=0;a<3;a++){const n=i[a],r=o[a];if(e.setFromBox(n,t),r.isSeparated(e))return!1}return!0}}(),J.prototype.intersectsTriangle=function(){const e=new Q,t=new Array(3),n=new O,r=new O,o=new s.Pq0;return function(i){this.needsUpdate&&this.update(),i.isExtendedTriangle?i.needsUpdate&&i.update():(e.copy(i),e.update(),i=e);const s=this.satBounds,a=this.satAxes;t[0]=i.a,t[1]=i.b,t[2]=i.c;for(let e=0;e<3;e++){const r=s[e],o=a[e];if(n.setFromPoints(o,t),r.isSeparated(n))return!1}const l=i.satBounds,c=i.satAxes,u=this.points;for(let e=0;e<3;e++){const t=l[e],r=c[e];if(n.setFromPoints(r,u),t.isSeparated(n))return!1}for(let e=0;e<3;e++){const i=a[e];for(let e=0;e<4;e++){const s=c[e];if(o.crossVectors(i,s),n.setFromPoints(o,t),r.setFromPoints(o,u),n.isSeparated(r))return!1}}return!0}}(),J.prototype.closestPointToPoint=function(e,t){return this.needsUpdate&&this.update(),t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t},J.prototype.distanceToPoint=function(){const e=new s.Pq0;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}(),J.prototype.distanceToBox=function(){const e=["x","y","z"],t=new Array(12).fill().map((()=>new s.cZY)),n=new Array(12).fill().map((()=>new s.cZY)),r=new s.Pq0,o=new s.Pq0;return function(i){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;if(this.needsUpdate&&this.update(),this.intersectsBox(i))return(a||l)&&(i.getCenter(o),this.closestPointToPoint(o,r),i.closestPointToPoint(r,o),a&&a.copy(r),l&&l.copy(o)),0;const c=s*s,u=i.min,d=i.max,f=this.points;let p=1/0;for(let e=0;e<8;e++){const t=f[e];o.copy(t).clamp(u,d);const n=t.distanceToSquared(o);if(n<p&&(p=n,a&&a.copy(t),l&&l.copy(o),n<c))return Math.sqrt(n)}let h=0;for(let r=0;r<3;r++)for(let o=0;o<=1;o++)for(let i=0;i<=1;i++){const s=(r+1)%3,a=(r+2)%3,l=1<<r|o<<s|i<<a,c=f[o<<s|i<<a],p=f[l];t[h].set(c,p);const m=e[r],g=e[s],y=e[a],x=n[h],v=x.start,w=x.end;v[m]=u[m],v[g]=o?u[g]:d[g],v[y]=i?u[y]:d[g],w[m]=d[m],w[g]=o?u[g]:d[g],w[y]=i?u[y]:d[g],h++}for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)for(let n=0;n<=1;n++){o.x=e?d.x:u.x,o.y=t?d.y:u.y,o.z=n?d.z:u.z,this.closestPointToPoint(o,r);const i=o.distanceToSquared(r);if(i<p&&(p=i,a&&a.copy(r),l&&l.copy(o),i<c))return Math.sqrt(i)}for(let e=0;e<12;e++){const i=t[e];for(let e=0;e<12;e++){const t=n[e];X(i,t,r,o);const s=r.distanceToSquared(o);if(s<p&&(p=s,a&&a.copy(r),l&&l.copy(o),s<c))return Math.sqrt(s)}}return Math.sqrt(p)}}();class ee{constructor(e){this._getNewPrimitive=e,this._primitives=[]}getPrimitive(){const e=this._primitives;return 0===e.length?this._getNewPrimitive():e.pop()}releasePrimitive(e){this._primitives.push(e)}}class te extends ee{constructor(){super((()=>new Q))}}const ne=new te;const re=new class{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const e=[];let t=null;this.setBuffer=n=>{t&&e.push(t),t=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,0!==e.length&&this.setBuffer(e.pop())}}};let oe,ie;const se=[],ae=new ee((()=>new s.NRn));function le(e,t,n,r,o,i){oe=ae.getPrimitive(),ie=ae.getPrimitive(),se.push(oe,ie),re.setBuffer(e._roots[t]);const s=ce(0,e.geometry,n,r,o,i);re.clearBuffer(),ae.releasePrimitive(oe),ae.releasePrimitive(ie),se.pop(),se.pop();const a=se.length;return a>0&&(ie=se[a-1],oe=se[a-2]),s}function ce(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const{float32Array:a,uint16Array:l,uint32Array:c}=re;let u=2*e;if(_(u,l)){const d=F(e,c),f=q(u,l);return x(e,a,oe),r(d,f,!1,s,i+e,oe)}{const p=R(e),h=U(e,c);let m,g,y,v,w=p,b=h;if(o&&(y=oe,v=ie,x(w,a,y),x(b,a,v),m=o(y),g=o(v),g<m)){w=h,b=p;const I=m;m=g,g=I,y=v}y||(y=oe,x(w,a,y));const P=n(y,_(2*w,l),m,s+1,i+w);let B;if(2===P){const S=M(w);B=r(S,E(w)-S,!0,s+1,i+w,y)}else B=P&&ce(w,t,n,r,o,i,s+1);if(B)return!0;v=ie,x(b,a,v);const A=n(v,_(2*b,l),g,s+1,i+b);let T;if(2===A){const k=M(b);T=r(k,E(b)-k,!0,s+1,i+b,v)}else T=A&&ce(b,t,n,r,o,i,s+1);return!!T;function M(e){const{uint16Array:t,uint32Array:n}=re;let r=2*e;for(;!_(r,t);)r=2*(e=R(e));return F(e,n)}function E(e){const{uint16Array:t,uint32Array:n}=re;let r=2*e;for(;!_(r,t);)r=2*(e=U(e,n));return F(e,n)+q(r,t)}}}const ue=new s.Pq0,de=new s.Pq0;const fe=new s.Pq0,pe=new s.Pq0,he=new s.Pq0,me=new s.I9Y,ge=new s.I9Y,ye=new s.I9Y,xe=new s.Pq0,ve=new s.Pq0,we=new s.Pq0,be=new s.Pq0;function Pe(e,t,n,r,o,i,a,l,c,u,d){fe.fromBufferAttribute(t,i),pe.fromBufferAttribute(t,a),he.fromBufferAttribute(t,l);const f=function(e,t,n,r,o,i,a,l){let c;if(c=i===s.hsX?e.intersectTriangle(r,n,t,!0,o):e.intersectTriangle(t,n,r,i!==s.$EB,o),null===c)return null;const u=e.origin.distanceTo(o);return u<a||u>l?null:{distance:u,point:o.clone()}}(e,fe,pe,he,be,c,u,d);if(f){r&&(me.fromBufferAttribute(r,i),ge.fromBufferAttribute(r,a),ye.fromBufferAttribute(r,l),f.uv=s.lMl.getInterpolation(be,fe,pe,he,me,ge,ye,new s.I9Y)),o&&(me.fromBufferAttribute(o,i),ge.fromBufferAttribute(o,a),ye.fromBufferAttribute(o,l),f.uv1=s.lMl.getInterpolation(be,fe,pe,he,me,ge,ye,new s.I9Y)),n&&(xe.fromBufferAttribute(n,i),ve.fromBufferAttribute(n,a),we.fromBufferAttribute(n,l),f.normal=s.lMl.getInterpolation(be,fe,pe,he,xe,ve,we,new s.Pq0),f.normal.dot(e.direction)>0&&f.normal.multiplyScalar(-1));const t={a:i,b:a,c:l,normal:new s.Pq0,materialIndex:0};s.lMl.getNormal(fe,pe,he,t.normal),f.face=t,f.faceIndex=i}return f}function Be(e,t,n,r,o,i,s){const a=3*r;let l=a+0,c=a+1,u=a+2;const d=e.index;e.index&&(l=d.getX(l),c=d.getX(c),u=d.getX(u));const{position:f,normal:p,uv:h,uv1:m}=e.attributes,g=Pe(n,f,p,h,m,l,c,u,t,i,s);return g?(g.faceIndex=r,o&&o.push(g),g):null}function Ae(e,t,n,r){const o=e.a,i=e.b,s=e.c;let a=t,l=t+1,c=t+2;n&&(a=n.getX(a),l=n.getX(l),c=n.getX(c)),o.x=r.getX(a),o.y=r.getY(a),o.z=r.getZ(a),i.x=r.getX(l),i.y=r.getY(l),i.z=r.getZ(l),s.x=r.getX(c),s.y=r.getY(c),s.z=r.getZ(c)}function Te(e,t,n,r,o,i,s){const{geometry:a}=n,{index:l}=a,c=a.attributes.position;for(let u=e,d=t+e;u<d;u++){let e;if(e=u,Ae(s,3*e,l,c),s.needsUpdate=!0,r(s,e,o,i))return!0}return!1}function Me(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t&&Array.isArray(t)&&(t=new Set(t));const n=e.geometry,r=n.index?n.index.array:null,o=n.attributes.position;let i,s,a,l,u=0;const d=e._roots;for(let c=0,p=d.length;c<p;c++)i=d[c],s=new Uint32Array(i),a=new Uint16Array(i),l=new Float32Array(i),f(0,u),u+=i.byteLength;function f(e,n){let i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const u=2*e;if(a[u+15]===c){const t=s[e+6];let n=1/0,i=1/0,c=1/0,d=-1/0,f=-1/0,p=-1/0;for(let e=3*t,s=3*(t+a[u+14]);e<s;e++){let t=r[e];const s=o.getX(t),a=o.getY(t),l=o.getZ(t);s<n&&(n=s),s>d&&(d=s),a<i&&(i=a),a>f&&(f=a),l<c&&(c=l),l>p&&(p=l)}return(l[e+0]!==n||l[e+1]!==i||l[e+2]!==c||l[e+3]!==d||l[e+4]!==f||l[e+5]!==p)&&(l[e+0]=n,l[e+1]=i,l[e+2]=c,l[e+3]=d,l[e+4]=f,l[e+5]=p,!0)}{const r=e+8,o=s[e+6],a=r+n,c=o+n;let u=i,d=!1,p=!1;t?u||(d=t.has(a),p=t.has(c),u=!d&&!p):(d=!0,p=!0);const h=u||p;let m=!1;(u||d)&&(m=f(r,n,u));let g=!1;h&&(g=f(o,n,u));const y=m||g;if(y)for(let t=0;t<3;t++){const n=r+t,i=o+t,s=l[n],a=l[n+3],c=l[i],u=l[i+3];l[e+t]=s<c?s:c,l[e+t+3]=a>u?a:u}return y}}}function Ee(e,t,n,r,o){let i,s,a,l,c,u;const d=1/n.direction.x,f=1/n.direction.y,p=1/n.direction.z,h=n.origin.x,m=n.origin.y,g=n.origin.z;let y=t[e],x=t[e+3],v=t[e+1],w=t[e+3+1],b=t[e+2],P=t[e+3+2];return d>=0?(i=(y-h)*d,s=(x-h)*d):(i=(x-h)*d,s=(y-h)*d),f>=0?(a=(v-m)*f,l=(w-m)*f):(a=(w-m)*f,l=(v-m)*f),!(i>l||a>s)&&((a>i||isNaN(i))&&(i=a),(l<s||isNaN(s))&&(s=l),p>=0?(c=(b-g)*p,u=(P-g)*p):(c=(P-g)*p,u=(b-g)*p),!(i>u||c>s)&&((c>i||i!==i)&&(i=c),(u<s||s!==s)&&(s=u),i<=o&&s>=r))}function Ie(e,t,n,r,o,i,s){re.setBuffer(e._roots[t]),Se(0,e,n,r,o,i,s),re.clearBuffer()}function Se(e,t,n,r,o,i,s){const{float32Array:a,uint16Array:l,uint32Array:c}=re,u=2*e;if(_(u,l)){!function(e,t,n,r,o,i,s,a){const{geometry:l,_indirectBuffer:c}=e;for(let u=r,d=r+o;u<d;u++)Be(l,t,n,u,i,s,a)}(t,n,r,F(e,c),q(u,l),o,i,s)}else{const l=R(e);Ee(l,a,r,i,s)&&Se(l,t,n,r,o,i,s);const u=U(e,c);Ee(u,a,r,i,s)&&Se(u,t,n,r,o,i,s)}}const ke=["x","y","z"];function _e(e,t,n,r,o,i){re.setBuffer(e._roots[t]);const s=Fe(0,e,n,r,o,i);return re.clearBuffer(),s}function Fe(e,t,n,r,o,i){const{float32Array:s,uint16Array:a,uint32Array:l}=re;let c=2*e;if(_(c,a)){return function(e,t,n,r,o,i,s){const{geometry:a,_indirectBuffer:l}=e;let c=1/0,u=null;for(let d=r,f=r+o;d<f;d++){let e;e=Be(a,t,n,d,null,i,s),e&&e.distance<c&&(u=e,c=e.distance)}return u}(t,n,r,F(e,l),q(c,a),o,i)}{const a=z(e,l),c=ke[a],u=r.direction[c]>=0;let d,f;u?(d=R(e),f=U(e,l)):(d=U(e,l),f=R(e));const p=Ee(d,s,r,o,i)?Fe(d,t,n,r,o,i):null;if(p){const e=p.point[c];if(u?e<=s[f+a]:e>=s[f+a+3])return p}const h=Ee(f,s,r,o,i)?Fe(f,t,n,r,o,i):null;return p&&h?p.distance<=h.distance?p:h:p||h||null}}const qe=new s.NRn,Re=new Q,Ue=new Q,ze=new s.kn4,De=new J,Ce=new J;function Ne(e,t,n,r){re.setBuffer(e._roots[t]);const o=Le(0,e,n,r);return re.clearBuffer(),o}function Le(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const{float32Array:i,uint16Array:s,uint32Array:a}=re;let l=2*e;null===o&&(n.boundingBox||n.computeBoundingBox(),De.set(n.boundingBox.min,n.boundingBox.max,r),o=De);if(!_(l,s)){const s=e+8,l=a[e+6];x(s,i,qe);if(o.intersectsBox(qe)&&Le(s,t,n,r,o))return!0;x(l,i,qe);return!!(o.intersectsBox(qe)&&Le(l,t,n,r,o))}{const o=t.geometry,c=o.index,u=o.attributes.position,d=n.index,f=n.attributes.position,p=F(e,a),h=q(l,s);if(ze.copy(r).invert(),n.boundsTree){x(e,i,Ce),Ce.matrix.copy(ze),Ce.needsUpdate=!0;return n.boundsTree.shapecast({intersectsBounds:e=>Ce.intersectsBox(e),intersectsTriangle:e=>{e.a.applyMatrix4(r),e.b.applyMatrix4(r),e.c.applyMatrix4(r),e.needsUpdate=!0;for(let t=3*p,n=3*(h+p);t<n;t+=3)if(Ae(Ue,t,c,u),Ue.needsUpdate=!0,e.intersectsTriangle(Ue))return!0;return!1}})}for(let e=3*p,t=3*(h+p);e<t;e+=3){Ae(Re,e,c,u),Re.a.applyMatrix4(ze),Re.b.applyMatrix4(ze),Re.c.applyMatrix4(ze),Re.needsUpdate=!0;for(let e=0,t=d.count;e<t;e+=3)if(Ae(Ue,e,d,f),Ue.needsUpdate=!0,Re.intersectsTriangle(Ue))return!0}}}const je=new s.kn4,He=new J,We=new J,Ze=new s.Pq0,Ve=new s.Pq0,Ye=new s.Pq0,Oe=new s.Pq0;function $e(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1/0;t.boundingBox||t.computeBoundingBox(),He.set(t.boundingBox.min,t.boundingBox.max,n),He.needsUpdate=!0;const a=e.geometry,l=a.attributes.position,c=a.index,u=t.attributes.position,d=t.index,f=ne.getPrimitive(),h=ne.getPrimitive();let m=Ze,g=Ve,y=null,x=null;o&&(y=Ye,x=Oe);let v=1/0,w=null,b=null;return je.copy(n).invert(),We.matrix.copy(je),e.shapecast({boundsTraverseOrder:e=>He.distanceToBox(e),intersectsBounds:(e,t,n)=>n<v&&n<s&&(t&&(We.min.copy(e.min),We.max.copy(e.max),We.needsUpdate=!0),!0),intersectsRange:(e,r)=>{if(t.boundsTree){return t.boundsTree.shapecast({boundsTraverseOrder:e=>We.distanceToBox(e),intersectsBounds:(e,t,n)=>n<v&&n<s,intersectsRange:(t,o)=>{for(let s=t,a=t+o;s<a;s++){Ae(h,3*s,d,u),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let t=e,n=e+r;t<n;t++){Ae(f,3*t,c,l),f.needsUpdate=!0;const e=f.distanceToTriangle(h,m,y);if(e<v&&(g.copy(m),x&&x.copy(y),v=e,w=t,b=s),e<i)return!0}}}})}for(let o=0,s=p(t);o<s;o++){Ae(h,3*o,d,u),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let t=e,n=e+r;t<n;t++){Ae(f,3*t,c,l),f.needsUpdate=!0;const e=f.distanceToTriangle(h,m,y);if(e<v&&(g.copy(m),x&&x.copy(y),v=e,w=t,b=o),e<i)return!0}}}}),ne.releasePrimitive(f),ne.releasePrimitive(h),v===1/0?null:(r.point?r.point.copy(g):r.point=g.clone(),r.distance=v,r.faceIndex=w,o&&(o.point?o.point.copy(x):o.point=x.clone(),o.point.applyMatrix4(je),g.applyMatrix4(je),o.distance=g.sub(o.point).length(),o.faceIndex=b),r)}function Xe(e,t,n,r,o,i,s){const{geometry:a}=n,{index:l}=a,c=a.attributes.position;for(let u=e,d=t+e;u<d;u++){let e;if(e=n.resolveTriangleIndex(u),Ae(s,3*e,l,c),s.needsUpdate=!0,r(s,e,o,i))return!0}return!1}function Ge(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t&&Array.isArray(t)&&(t=new Set(t));const n=e.geometry,r=n.index?n.index.array:null,o=n.attributes.position;let i,s,a,l,u=0;const d=e._roots;for(let c=0,p=d.length;c<p;c++)i=d[c],s=new Uint32Array(i),a=new Uint16Array(i),l=new Float32Array(i),f(0,u),u+=i.byteLength;function f(n,i){let u=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const d=2*n;if(a[d+15]===c){const t=s[n+6];let i=1/0,c=1/0,u=1/0,f=-1/0,p=-1/0,h=-1/0;for(let n=t,s=t+a[d+14];n<s;n++){const t=3*e.resolveTriangleIndex(n);for(let e=0;e<3;e++){let n=t+e;n=r?r[n]:n;const s=o.getX(n),a=o.getY(n),l=o.getZ(n);s<i&&(i=s),s>f&&(f=s),a<c&&(c=a),a>p&&(p=a),l<u&&(u=l),l>h&&(h=l)}}return(l[n+0]!==i||l[n+1]!==c||l[n+2]!==u||l[n+3]!==f||l[n+4]!==p||l[n+5]!==h)&&(l[n+0]=i,l[n+1]=c,l[n+2]=u,l[n+3]=f,l[n+4]=p,l[n+5]=h,!0)}{const e=n+8,r=s[n+6],o=e+i,a=r+i;let c=u,d=!1,p=!1;t?c||(d=t.has(o),p=t.has(a),c=!d&&!p):(d=!0,p=!0);const h=c||p;let m=!1;(c||d)&&(m=f(e,i,c));let g=!1;h&&(g=f(r,i,c));const y=m||g;if(y)for(let t=0;t<3;t++){const o=e+t,i=r+t,s=l[o],a=l[o+3],c=l[i],u=l[i+3];l[n+t]=s<c?s:c,l[n+t+3]=a>u?a:u}return y}}}function Ke(e,t,n,r,o,i,s){re.setBuffer(e._roots[t]),Qe(0,e,n,r,o,i,s),re.clearBuffer()}function Qe(e,t,n,r,o,i,s){const{float32Array:a,uint16Array:l,uint32Array:c}=re,u=2*e;if(_(u,l)){!function(e,t,n,r,o,i,s,a){const{geometry:l,_indirectBuffer:c}=e;for(let u=r,d=r+o;u<d;u++)Be(l,t,n,c?c[u]:u,i,s,a)}(t,n,r,F(e,c),q(u,l),o,i,s)}else{const l=R(e);Ee(l,a,r,i,s)&&Qe(l,t,n,r,o,i,s);const u=U(e,c);Ee(u,a,r,i,s)&&Qe(u,t,n,r,o,i,s)}}const Je=["x","y","z"];function et(e,t,n,r,o,i){re.setBuffer(e._roots[t]);const s=tt(0,e,n,r,o,i);return re.clearBuffer(),s}function tt(e,t,n,r,o,i){const{float32Array:s,uint16Array:a,uint32Array:l}=re;let c=2*e;if(_(c,a)){return function(e,t,n,r,o,i,s){const{geometry:a,_indirectBuffer:l}=e;let c=1/0,u=null;for(let d=r,f=r+o;d<f;d++){let e;e=Be(a,t,n,l?l[d]:d,null,i,s),e&&e.distance<c&&(u=e,c=e.distance)}return u}(t,n,r,F(e,l),q(c,a),o,i)}{const a=z(e,l),c=Je[a],u=r.direction[c]>=0;let d,f;u?(d=R(e),f=U(e,l)):(d=U(e,l),f=R(e));const p=Ee(d,s,r,o,i)?tt(d,t,n,r,o,i):null;if(p){const e=p.point[c];if(u?e<=s[f+a]:e>=s[f+a+3])return p}const h=Ee(f,s,r,o,i)?tt(f,t,n,r,o,i):null;return p&&h?p.distance<=h.distance?p:h:p||h||null}}const nt=new s.NRn,rt=new Q,ot=new Q,it=new s.kn4,st=new J,at=new J;function lt(e,t,n,r){re.setBuffer(e._roots[t]);const o=ct(0,e,n,r);return re.clearBuffer(),o}function ct(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const{float32Array:i,uint16Array:s,uint32Array:a}=re;let l=2*e;null===o&&(n.boundingBox||n.computeBoundingBox(),st.set(n.boundingBox.min,n.boundingBox.max,r),o=st);if(!_(l,s)){const s=e+8,l=a[e+6];x(s,i,nt);if(o.intersectsBox(nt)&&ct(s,t,n,r,o))return!0;x(l,i,nt);return!!(o.intersectsBox(nt)&&ct(l,t,n,r,o))}{const o=t.geometry,c=o.index,u=o.attributes.position,d=n.index,f=n.attributes.position,p=F(e,a),h=q(l,s);if(it.copy(r).invert(),n.boundsTree){x(e,i,at),at.matrix.copy(it),at.needsUpdate=!0;return n.boundsTree.shapecast({intersectsBounds:e=>at.intersectsBox(e),intersectsTriangle:e=>{e.a.applyMatrix4(r),e.b.applyMatrix4(r),e.c.applyMatrix4(r),e.needsUpdate=!0;for(let n=p,r=h+p;n<r;n++)if(Ae(ot,3*t.resolveTriangleIndex(n),c,u),ot.needsUpdate=!0,e.intersectsTriangle(ot))return!0;return!1}})}for(let e=p,n=h+p;e<n;e++){const n=t.resolveTriangleIndex(e);Ae(rt,3*n,c,u),rt.a.applyMatrix4(it),rt.b.applyMatrix4(it),rt.c.applyMatrix4(it),rt.needsUpdate=!0;for(let e=0,t=d.count;e<t;e+=3)if(Ae(ot,e,d,f),ot.needsUpdate=!0,rt.intersectsTriangle(ot))return!0}}}const ut=new s.kn4,dt=new J,ft=new J,pt=new s.Pq0,ht=new s.Pq0,mt=new s.Pq0,gt=new s.Pq0;function yt(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1/0;t.boundingBox||t.computeBoundingBox(),dt.set(t.boundingBox.min,t.boundingBox.max,n),dt.needsUpdate=!0;const a=e.geometry,l=a.attributes.position,c=a.index,u=t.attributes.position,d=t.index,f=ne.getPrimitive(),h=ne.getPrimitive();let m=pt,g=ht,y=null,x=null;o&&(y=mt,x=gt);let v=1/0,w=null,b=null;return ut.copy(n).invert(),ft.matrix.copy(ut),e.shapecast({boundsTraverseOrder:e=>dt.distanceToBox(e),intersectsBounds:(e,t,n)=>n<v&&n<s&&(t&&(ft.min.copy(e.min),ft.max.copy(e.max),ft.needsUpdate=!0),!0),intersectsRange:(r,o)=>{if(t.boundsTree){const a=t.boundsTree;return a.shapecast({boundsTraverseOrder:e=>ft.distanceToBox(e),intersectsBounds:(e,t,n)=>n<v&&n<s,intersectsRange:(t,s)=>{for(let p=t,P=t+s;p<P;p++){const t=a.resolveTriangleIndex(p);Ae(h,3*t,d,u),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let n=r,s=r+o;n<s;n++){const t=e.resolveTriangleIndex(n);Ae(f,3*t,c,l),f.needsUpdate=!0;const r=f.distanceToTriangle(h,m,y);if(r<v&&(g.copy(m),x&&x.copy(y),v=r,w=n,b=p),r<i)return!0}}}})}for(let s=0,a=p(t);s<a;s++){Ae(h,3*s,d,u),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let t=r,n=r+o;t<n;t++){const n=e.resolveTriangleIndex(t);Ae(f,3*n,c,l),f.needsUpdate=!0;const r=f.distanceToTriangle(h,m,y);if(r<v&&(g.copy(m),x&&x.copy(y),v=r,w=t,b=s),r<i)return!0}}}}),ne.releasePrimitive(f),ne.releasePrimitive(h),v===1/0?null:(r.point?r.point.copy(g):r.point=g.clone(),r.distance=v,r.faceIndex=w,o&&(o.point?o.point.copy(x):o.point=x.clone(),o.point.applyMatrix4(ut),g.applyMatrix4(ut),o.distance=g.sub(o.point).length(),o.faceIndex=b),r)}const xt=new re.constructor,vt=new re.constructor,wt=new ee((()=>new s.NRn)),bt=new s.NRn,Pt=new s.NRn,Bt=new s.NRn,At=new s.NRn;let Tt=!1;function Mt(e,t,n,r,o){let i,s,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,c=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,u=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0,d=arguments.length>9&&void 0!==arguments[9]?arguments[9]:null,f=arguments.length>10&&void 0!==arguments[10]&&arguments[10];f?(i=vt,s=xt):(i=xt,s=vt);const p=i.float32Array,h=i.uint32Array,m=i.uint16Array,g=s.float32Array,y=s.uint32Array,v=s.uint16Array,w=2*t,b=_(2*e,m),P=_(w,v);let B=!1;if(P&&b)B=f?o(F(t,y),q(2*t,v),F(e,h),q(2*e,m),u,l+t,c,a+e):o(F(e,h),q(2*e,m),F(t,y),q(2*t,v),c,a+e,u,l+t);else if(P){const i=wt.getPrimitive();x(t,g,i),i.applyMatrix4(n);const s=R(e),d=U(e,h);x(s,p,bt),x(d,p,Pt);const m=i.intersectsBox(bt),y=i.intersectsBox(Pt);B=m&&Mt(t,s,r,n,o,l,a,u,c+1,i,!f)||y&&Mt(t,d,r,n,o,l,a,u,c+1,i,!f),wt.releasePrimitive(i)}else{const i=R(t),s=U(t,y);x(i,g,Bt),x(s,g,At);const m=d.intersectsBox(Bt),v=d.intersectsBox(At);if(m&&v)B=Mt(e,i,n,r,o,a,l,c,u+1,d,f)||Mt(e,s,n,r,o,a,l,c,u+1,d,f);else if(m)if(b)B=Mt(e,i,n,r,o,a,l,c,u+1,d,f);else{const t=wt.getPrimitive();t.copy(Bt).applyMatrix4(n);const s=R(e),d=U(e,h);x(s,p,bt),x(d,p,Pt);const m=t.intersectsBox(bt),g=t.intersectsBox(Pt);B=m&&Mt(i,s,r,n,o,l,a,u,c+1,t,!f)||g&&Mt(i,d,r,n,o,l,a,u,c+1,t,!f),wt.releasePrimitive(t)}else if(v)if(b)B=Mt(e,s,n,r,o,a,l,c,u+1,d,f);else{const t=wt.getPrimitive();t.copy(At).applyMatrix4(n);const i=R(e),d=U(e,h);x(i,p,bt),x(d,p,Pt);const m=t.intersectsBox(bt),g=t.intersectsBox(Pt);B=m&&Mt(s,i,r,n,o,l,a,u,c+1,t,!f)||g&&Mt(s,d,r,n,o,l,a,u,c+1,t,!f),wt.releasePrimitive(t)}}return B}const Et=new J,It=new s.NRn,St={strategy:0,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class kt{static serialize(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t={cloneBuffers:!0,...t};const n=e.geometry,r=e._roots,o=e._indirectBuffer,i=n.getIndex();let s;return s=t.cloneBuffers?{roots:r.map((e=>e.slice())),index:i?i.array.slice():null,indirectBuffer:o?o.slice():null}:{roots:r,index:i?i.array:null,indirectBuffer:o},s}static deserialize(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};n={setIndex:!0,indirect:Boolean(e.indirectBuffer),...n};const{index:r,roots:o,indirectBuffer:i}=e,a=new kt(t,{...n,[d]:!0});if(a._roots=o,a._indirectBuffer=i||null,n.setIndex){const n=t.getIndex();if(null===n){const n=new s.THS(e.index,1,!1);t.setIndex(n)}else n.array!==r&&(n.array.set(r),n.needsUpdate=!0)}return a}get indirect(){return!!this._indirectBuffer}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!e.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e.index&&e.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if(t=Object.assign({...St,[d]:!1},t),t.useSharedArrayBuffer&&"undefined"===typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=e,this._roots=null,this._indirectBuffer=null,t[d]||(Y(this,t),!e.boundingBox&&t.setBoundingBox&&(e.boundingBox=this.getBoundingBox(new s.NRn))),this.resolveTriangleIndex=t.indirect?e=>this._indirectBuffer[e]:e=>e}refit(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return(this.indirect?Ge:Me)(this,e)}traverse(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=this._roots[t],r=new Uint32Array(n),o=new Uint16Array(n);!function t(i){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const a=2*i,l=o[a+15]===c;if(l){const t=r[i+6],c=o[a+14];e(s,l,new Float32Array(n,4*i,6),t,c)}else{const o=i+8,a=r[i+6],c=r[i+7];e(s,l,new Float32Array(n,4*i,6),c)||(t(o,s+1),t(a,s+1))}}(0)}raycast(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:s.hB5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;const o=this._roots,i=this.geometry,a=[],l=t.isMaterial,c=Array.isArray(t),u=i.groups,d=l?t.side:t,f=this.indirect?Ke:Ie;for(let s=0,p=o.length;s<p;s++){const o=c?t[u[s].materialIndex].side:d,i=a.length;if(f(this,s,o,e,a,n,r),c){const e=u[s].materialIndex;for(let t=i,n=a.length;t<n;t++)a[t].face.materialIndex=e}}return a}raycastFirst(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:s.hB5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;const o=this._roots,i=this.geometry,a=t.isMaterial,l=Array.isArray(t);let c=null;const u=i.groups,d=a?t.side:t,f=this.indirect?et:_e;for(let s=0,p=o.length;s<p;s++){const o=f(this,s,l?t[u[s].materialIndex].side:d,e,n,r);null!=o&&(null==c||o.distance<c.distance)&&(c=o,l&&(o.face.materialIndex=u[s].materialIndex))}return c}intersectsGeometry(e,t){let n=!1;const r=this._roots,o=this.indirect?lt:Ne;for(let i=0,s=r.length;i<s&&(n=o(this,i,e,t),!n);i++);return n}shapecast(e){const t=ne.getPrimitive(),n=this.indirect?Xe:Te;let{boundsTraverseOrder:r,intersectsBounds:o,intersectsRange:i,intersectsTriangle:s}=e;if(i&&s){const e=i;i=(r,o,i,a,l)=>!!e(r,o,i,a,l)||n(r,o,this,s,i,a,t)}else i||(i=s?(e,r,o,i)=>n(e,r,this,s,o,i,t):(e,t,n)=>n);let a=!1,l=0;const c=this._roots;for(let u=0,d=c.length;u<d;u++){const e=c[u];if(a=le(this,u,o,i,r,l),a)break;l+=e.byteLength}return ne.releasePrimitive(t),a}bvhcast(e,t,n){let{intersectsRanges:r,intersectsTriangles:o}=n;const i=ne.getPrimitive(),a=this.geometry.index,l=this.geometry.attributes.position,c=this.indirect?e=>{const t=this.resolveTriangleIndex(e);Ae(i,3*t,a,l)}:e=>{Ae(i,3*e,a,l)},u=ne.getPrimitive(),d=e.geometry.index,f=e.geometry.attributes.position,p=e.indirect?t=>{const n=e.resolveTriangleIndex(t);Ae(u,3*n,d,f)}:e=>{Ae(u,3*e,d,f)};if(o){const e=(e,n,r,s,a,l,d,f)=>{for(let h=r,m=r+s;h<m;h++){p(h),u.a.applyMatrix4(t),u.b.applyMatrix4(t),u.c.applyMatrix4(t),u.needsUpdate=!0;for(let t=e,r=e+n;t<r;t++)if(c(t),i.needsUpdate=!0,o(i,u,t,h,a,l,d,f))return!0}return!1};if(r){const t=r;r=function(n,r,o,i,s,a,l,c){return!!t(n,r,o,i,s,a,l,c)||e(n,r,o,i,s,a,l,c)}}else r=e}return function(e,t,n,r){if(Tt)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Tt=!0;const o=e._roots,i=t._roots;let a,l=0,c=0;const u=(new s.kn4).copy(n).invert();for(let s=0,d=o.length;s<d;s++){xt.setBuffer(o[s]),c=0;const e=wt.getPrimitive();x(0,xt.float32Array,e),e.applyMatrix4(u);for(let t=0,o=i.length;t<o&&(vt.setBuffer(i[t]),a=Mt(0,0,n,u,r,l,c,0,0,e),vt.clearBuffer(),c+=i[t].length,!a);t++);if(wt.releasePrimitive(e),xt.clearBuffer(),l+=o[s].length,a)break}return Tt=!1,a}(this,e,t,r)}intersectsBox(e,t){return Et.set(e.min,e.max,t),Et.needsUpdate=!0,this.shapecast({intersectsBounds:e=>Et.intersectsBox(e),intersectsTriangle:e=>Et.intersectsTriangle(e)})}intersectsSphere(e){return this.shapecast({intersectsBounds:t=>e.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(e)})}closestPointToGeometry(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1/0;return(this.indirect?yt:$e)(this,e,t,n,r,o,i)}closestPointToPoint(e){return function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1/0;const i=r*r,s=o*o;let a=1/0,l=null;if(e.shapecast({boundsTraverseOrder:e=>(ue.copy(t).clamp(e.min,e.max),ue.distanceToSquared(t)),intersectsBounds:(e,t,n)=>n<a&&n<s,intersectsTriangle:(e,n)=>{e.closestPointToPoint(t,ue);const r=t.distanceToSquared(ue);return r<a&&(de.copy(ue),a=r,l=n),r<i}}),a===1/0)return null;const c=Math.sqrt(a);return n.point?n.point.copy(de):n.point=de.clone(),n.distance=c,n.faceIndex=l,n}(this,e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0)}getBoundingBox(e){e.makeEmpty();return this._roots.forEach((t=>{x(0,new Float32Array(t),It),e.union(It)})),e}}const _t=s.$Ed||null,Ft=(parseInt(s.sPf),new s.RlV),qt=new s.Pq0,Rt=new s.kn4,Ut=s.eaF.prototype.raycast,zt=null!==_t?_t.prototype.raycast:null,Dt=new s.Pq0,Ct=new s.eaF,Nt=[];function Lt(e,t){this.isBatchedMesh?jt.call(this,e,t):Ht.call(this,e,t)}function jt(e,t){if(this.boundsTrees){const n=this.boundsTrees,r=this._drawInfo,o=this._drawRanges,i=this.matrixWorld;Ct.material=this.material,Ct.geometry=this.geometry;const a=Ct.geometry.boundsTree,l=Ct.geometry.drawRange;null===Ct.geometry.boundingSphere&&(Ct.geometry.boundingSphere=new s.iyt);for(let s=0,c=r.length;s<c;s++){if(!this.getVisibleAt(s))continue;const a=r[s].geometryIndex;if(Ct.geometry.boundsTree=n[a],this.getMatrixAt(s,Ct.matrixWorld).premultiply(i),!Ct.geometry.boundsTree){this.getBoundingBoxAt(a,Ct.geometry.boundingBox),this.getBoundingSphereAt(a,Ct.geometry.boundingSphere);const e=o[a];Ct.geometry.setDrawRange(e.start,e.count)}Ct.raycast(e,Nt);for(let e=0,n=Nt.length;e<n;e++){const n=Nt[e];n.object=this,n.batchId=s,t.push(n)}Nt.length=0}Ct.geometry.boundsTree=a,Ct.geometry.drawRange=l,Ct.material=null,Ct.geometry=null}else zt.call(this,e,t)}function Ht(e,t){if(this.geometry.boundsTree){if(void 0===this.material)return;Rt.copy(this.matrixWorld).invert(),Ft.copy(e.ray).applyMatrix4(Rt),Dt.setFromMatrixScale(this.matrixWorld),qt.copy(Ft.direction).multiply(Dt);const n=qt.length(),r=e.near/n,o=e.far/n,i=this.geometry.boundsTree;if(!0===e.firstHitOnly){const n=f(i.raycastFirst(Ft,this.material,r,o),this,e);n&&t.push(n)}else{const n=i.raycast(Ft,this.material,r,o);for(let r=0,o=n.length;r<o;r++){const o=f(n[r],this,e);o&&t.push(o)}}}else Ut.call(this,e,t)}function Wt(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return this.boundsTree=new kt(this,e),this.boundsTree}function Zt(){this.boundsTree=null}const Vt=e=>e.isMesh;const Yt=i.forwardRef(((e,t)=>{let{enabled:n=!0,firstHitOnly:l=!1,children:c,strategy:u=a,verbose:d=!1,setBoundingBox:f=!0,maxDepth:p=40,maxLeafTris:h=10,indirect:m=!1,...g}=e;const y=i.useRef(null),x=(0,o.D)((e=>e.raycaster));return i.useImperativeHandle(t,(()=>y.current),[]),i.useEffect((()=>{if(n){const e={strategy:u,verbose:d,setBoundingBox:f,maxDepth:p,maxLeafTris:h,indirect:m},t=y.current;return x.firstHitOnly=l,t.traverse((t=>{Vt(t)&&!t.geometry.boundsTree&&t.raycast===s.eaF.prototype.raycast&&(t.raycast=Lt,t.geometry.computeBoundsTree=Wt,t.geometry.disposeBoundsTree=Zt,t.geometry.computeBoundsTree(e))})),()=>{delete x.firstHitOnly,t.traverse((e=>{Vt(e)&&e.geometry.boundsTree&&(e.geometry.disposeBoundsTree(),e.raycast=s.eaF.prototype.raycast)}))}}}),[]),i.createElement("group",(0,r.A)({ref:y},g),c)}))},9381:(e,t,n)=>{n.d(t,{M:()=>s});var r=n(7226),o=n(9950),i=n(2880);function s(e){let{all:t,scene:n,camera:s}=e;const a=(0,i.D)((e=>{let{gl:t}=e;return t})),l=(0,i.D)((e=>{let{camera:t}=e;return t})),c=(0,i.D)((e=>{let{scene:t}=e;return t}));return o.useLayoutEffect((()=>{const e=[];t&&(n||c).traverse((t=>{!1===t.visible&&(e.push(t),t.visible=!0)})),a.compile(n||c,s||l);const o=new r.o6l(128);new r.F1T(.01,1e5,o).update(a,n||c),o.dispose(),e.forEach((e=>e.visible=!1))}),[]),null}}}]);