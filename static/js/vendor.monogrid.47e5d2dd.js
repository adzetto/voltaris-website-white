"use strict";(self.webpackChunkvoltaris_website=self.webpackChunkvoltaris_website||[]).push([[992],{6630:(e,t,r)=>{r.d(t,{j:()=>u,pb:()=>v});var a=r(7226),i=r(3437);const n=(e,t,r)=>{let i;switch(e){case a.OUM:i=new Uint8ClampedArray(t*r*4);break;case a.ix0:i=new Uint16Array(t*r*4);break;case a.bkx:i=new Uint32Array(t*r*4);break;case a.tJf:i=new Int8Array(t*r*4);break;case a.fBL:i=new Int16Array(t*r*4);break;case a.Yuy:i=new Int32Array(t*r*4);break;case a.RQf:i=new Float32Array(t*r*4);break;default:throw new Error("Unsupported data type")}return i};let s;class o{constructor(e){var t,r,i,d,h,l,p,g,c,m,f,u,v,w,y,M;this._rendererIsDisposable=!1,this._supportsReadPixels=!0,this.render=()=>{this._renderer.setRenderTarget(this._renderTarget);try{this._renderer.render(this._scene,this._camera)}catch(e){throw this._renderer.setRenderTarget(null),e}this._renderer.setRenderTarget(null)},this._width=e.width,this._height=e.height,this._type=e.type,this._colorSpace=e.colorSpace;const _={format:a.GWd,depthBuffer:!1,stencilBuffer:!1,type:this._type,colorSpace:this._colorSpace,anisotropy:void 0!==(null===(t=e.renderTargetOptions)||void 0===t?void 0:t.anisotropy)?null===(r=e.renderTargetOptions)||void 0===r?void 0:r.anisotropy:1,generateMipmaps:void 0!==(null===(i=e.renderTargetOptions)||void 0===i?void 0:i.generateMipmaps)&&(null===(d=e.renderTargetOptions)||void 0===d?void 0:d.generateMipmaps),magFilter:void 0!==(null===(h=e.renderTargetOptions)||void 0===h?void 0:h.magFilter)?null===(l=e.renderTargetOptions)||void 0===l?void 0:l.magFilter:a.k6q,minFilter:void 0!==(null===(p=e.renderTargetOptions)||void 0===p?void 0:p.minFilter)?null===(g=e.renderTargetOptions)||void 0===g?void 0:g.minFilter:a.k6q,samples:void 0!==(null===(c=e.renderTargetOptions)||void 0===c?void 0:c.samples)?null===(m=e.renderTargetOptions)||void 0===m?void 0:m.samples:void 0,wrapS:void 0!==(null===(f=e.renderTargetOptions)||void 0===f?void 0:f.wrapS)?null===(u=e.renderTargetOptions)||void 0===u?void 0:u.wrapS:a.ghU,wrapT:void 0!==(null===(v=e.renderTargetOptions)||void 0===v?void 0:v.wrapT)?null===(w=e.renderTargetOptions)||void 0===w?void 0:w.wrapT:a.ghU};if(this._material=e.material,e.renderer?this._renderer=e.renderer:(this._renderer=o.instantiateRenderer(),this._rendererIsDisposable=!0),this._scene=new a.Z58,this._camera=new a.qUd,this._camera.position.set(0,0,10),this._camera.left=-.5,this._camera.right=.5,this._camera.top=.5,this._camera.bottom=-.5,this._camera.updateProjectionMatrix(),!((e,t,r,i)=>{if(void 0!==s)return s;const o=new a.nWS(1,1,i);t.setRenderTarget(o);const d=new a.eaF(new a.bdM,new a.V9B({color:16777215}));t.render(d,r),t.setRenderTarget(null);const h=n(e,o.width,o.height);return t.readRenderTargetPixels(o,0,0,o.width,o.height,h),o.dispose(),d.geometry.dispose(),d.material.dispose(),s=0!==h[0],s})(this._type,this._renderer,this._camera,_)){let e;if(this._type===a.ix0)e=this._renderer.extensions.has("EXT_color_buffer_float")?a.RQf:void 0;void 0!==e?(console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${a.RQf}`),this._type=e):(this._supportsReadPixels=!1,console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"))}this._quad=new a.eaF(new a.bdM,this._material),this._quad.geometry.computeBoundingBox(),this._scene.add(this._quad),this._renderTarget=new a.nWS(this.width,this.height,_),this._renderTarget.texture.mapping=void 0!==(null===(y=e.renderTargetOptions)||void 0===y?void 0:y.mapping)?null===(M=e.renderTargetOptions)||void 0===M?void 0:M.mapping:a.UTZ}static instantiateRenderer(){const e=new i.WebGLRenderer;return e.setSize(128,128),e}toArray(){if(!this._supportsReadPixels)throw new Error("Can't read pixels in this browser");const e=n(this._type,this._width,this._height);return this._renderer.readRenderTargetPixels(this._renderTarget,0,0,this._width,this._height,e),e}toDataTexture(e){const t=new a.GYF(this.toArray(),this.width,this.height,a.GWd,this._type,(null===e||void 0===e?void 0:e.mapping)||a.UTZ,(null===e||void 0===e?void 0:e.wrapS)||a.ghU,(null===e||void 0===e?void 0:e.wrapT)||a.ghU,(null===e||void 0===e?void 0:e.magFilter)||a.k6q,(null===e||void 0===e?void 0:e.minFilter)||a.k6q,(null===e||void 0===e?void 0:e.anisotropy)||1,a.Zr2);return t.generateMipmaps=void 0!==(null===e||void 0===e?void 0:e.generateMipmaps)&&(null===e||void 0===e?void 0:e.generateMipmaps),t}disposeOnDemandRenderer(){this._renderer.setRenderTarget(null),this._rendererIsDisposable&&(this._renderer.dispose(),this._renderer.forceContextLoss())}dispose(e){this.disposeOnDemandRenderer(),e&&this.renderTarget.dispose(),this.material instanceof a.BKk&&Object.values(this.material.uniforms).forEach((e=>{e.value instanceof a.gPd&&e.value.dispose()})),Object.values(this.material).forEach((e=>{e instanceof a.gPd&&e.dispose()})),this.material.dispose(),this._quad.geometry.dispose()}get width(){return this._width}set width(e){this._width=e,this._renderTarget.setSize(this._width,this._height)}get height(){return this._height}set height(e){this._height=e,this._renderTarget.setSize(this._width,this._height)}get renderer(){return this._renderer}get renderTarget(){return this._renderTarget}set renderTarget(e){this._renderTarget=e,this._width=e.width,this._height=e.height}get material(){return this._material}get type(){return this._type}get colorSpace(){return this._colorSpace}}class d extends a.BKk{constructor(e){let{gamma:t,offsetHdr:r,offsetSdr:i,gainMapMin:n,gainMapMax:s,maxDisplayBoost:o,hdrCapacityMin:d,hdrCapacityMax:h,sdr:l,gainMap:p}=e;super({name:"GainMapDecoderMaterial",vertexShader:"\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader:"\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n",uniforms:{sdr:{value:l},gainMap:{value:p},gamma:{value:new a.Pq0(1/t[0],1/t[1],1/t[2])},offsetHdr:{value:(new a.Pq0).fromArray(r)},offsetSdr:{value:(new a.Pq0).fromArray(i)},gainMapMin:{value:(new a.Pq0).fromArray(n)},gainMapMax:{value:(new a.Pq0).fromArray(s)},weightFactor:{value:(Math.log2(o)-d)/(h-d)}},blending:a.XIg,depthTest:!1,depthWrite:!1}),this._maxDisplayBoost=o,this._hdrCapacityMin=d,this._hdrCapacityMax=h,this.needsUpdate=!0,this.uniformsNeedUpdate=!0}get sdr(){return this.uniforms.sdr.value}set sdr(e){this.uniforms.sdr.value=e}get gainMap(){return this.uniforms.gainMap.value}set gainMap(e){this.uniforms.gainMap.value=e}get offsetHdr(){return this.uniforms.offsetHdr.value.toArray()}set offsetHdr(e){this.uniforms.offsetHdr.value.fromArray(e)}get offsetSdr(){return this.uniforms.offsetSdr.value.toArray()}set offsetSdr(e){this.uniforms.offsetSdr.value.fromArray(e)}get gainMapMin(){return this.uniforms.gainMapMin.value.toArray()}set gainMapMin(e){this.uniforms.gainMapMin.value.fromArray(e)}get gainMapMax(){return this.uniforms.gainMapMax.value.toArray()}set gainMapMax(e){this.uniforms.gainMapMax.value.fromArray(e)}get gamma(){const e=this.uniforms.gamma.value;return[1/e.x,1/e.y,1/e.z]}set gamma(e){const t=this.uniforms.gamma.value;t.x=1/e[0],t.y=1/e[1],t.z=1/e[2]}get hdrCapacityMin(){return this._hdrCapacityMin}set hdrCapacityMin(e){this._hdrCapacityMin=e,this.calculateWeight()}get hdrCapacityMax(){return this._hdrCapacityMax}set hdrCapacityMax(e){this._hdrCapacityMax=e,this.calculateWeight()}get maxDisplayBoost(){return this._maxDisplayBoost}set maxDisplayBoost(e){this._maxDisplayBoost=Math.max(1,Math.min(65504,e)),this.calculateWeight()}calculateWeight(){const e=(Math.log2(this._maxDisplayBoost)-this._hdrCapacityMin)/(this._hdrCapacityMax-this._hdrCapacityMin);this.uniforms.weightFactor.value=Math.max(0,Math.min(1,e))}}class h extends Error{}class l extends Error{}const p=(e,t,r)=>{const a=new RegExp(`${t}="([^"]*)"`,"i").exec(e);if(a)return a[1];const i=new RegExp(`<${t}[^>]*>([\\s\\S]*?)</${t}>`,"i").exec(e);if(i){const e=i[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g);return e&&3===e.length?e.map((e=>e.replace(/<\/?rdf:li>/g,""))):i[1].trim()}if(void 0!==r)return r;throw new Error(`Can't find ${t} in gainmap metadata`)};class g{constructor(e){this.options={debug:!(!e||void 0===e.debug)&&e.debug,extractFII:!e||void 0===e.extractFII||e.extractFII,extractNonFII:!e||void 0===e.extractNonFII||e.extractNonFII}}extract(e){return new Promise(((t,r)=>{const a=this.options.debug,i=new DataView(e.buffer);if(65496!==i.getUint16(0))return void r(new Error("Not a valid jpeg"));const n=i.byteLength;let s,o=2,d=0;for(;o<n;){if(++d>250)return void r(new Error(`Found no marker after ${d} loops \ud83d\ude35`));if(255!==i.getUint8(o))return void r(new Error(`Not a valid marker at offset 0x${o.toString(16)}, found: 0x${i.getUint8(o).toString(16)}`));if(s=i.getUint8(o+1),a&&console.log(`Marker: ${s.toString(16)}`),226===s){a&&console.log("Found APP2 marker (0xffe2)");const e=o+4;if(1297106432===i.getUint32(e)){const a=e+4;let n;if(18761===i.getUint16(a))n=!1;else{if(19789!==i.getUint16(a))return void r(new Error("No valid endianness marker found in TIFF header"));n=!0}if(42!==i.getUint16(a+2,!n))return void r(new Error("Not valid TIFF data! (no 0x002A marker)"));const s=i.getUint32(a+4,!n);if(s<8)return void r(new Error("Not valid TIFF data! (First offset less than 8)"));const o=a+s,d=i.getUint16(o,!n),h=o+2;let l=0;for(let e=h;e<h+12*d;e+=12)45057===i.getUint16(e,!n)&&(l=i.getUint32(e+8,!n));const p=o+2+12*d+4,g=[];for(let e=p;e<p+16*l;e+=16){const t={MPType:i.getUint32(e,!n),size:i.getUint32(e+4,!n),dataOffset:i.getUint32(e+8,!n),dependantImages:i.getUint32(e+12,!n),start:-1,end:-1,isFII:!1};t.dataOffset?(t.start=a+t.dataOffset,t.isFII=!1):(t.start=0,t.isFII=!0),t.end=t.start+t.size,g.push(t)}if(this.options.extractNonFII&&g.length){const e=new Blob([i]),r=[];for(const t of g){if(t.isFII&&!this.options.extractFII)continue;const a=e.slice(t.start,t.end+1,"image/jpeg");r.push(a)}t(r)}}}o+=2+i.getUint16(o+2)}}))}}const c=async e=>{const t=(e=>{let t;t="undefined"!==typeof TextDecoder?(new TextDecoder).decode(e):e.toString();let r=t.indexOf("<x:xmpmeta");for(;-1!==r;){const e=t.indexOf("x:xmpmeta>",r),i=t.slice(r,e+10);try{const e=p(i,"hdrgm:GainMapMin","0"),t=p(i,"hdrgm:GainMapMax"),r=p(i,"hdrgm:Gamma","1"),a=p(i,"hdrgm:OffsetSDR","0.015625"),n=p(i,"hdrgm:OffsetHDR","0.015625"),s=/hdrgm:HDRCapacityMin="([^"]*)"/.exec(i),o=s?s[1]:"0",d=/hdrgm:HDRCapacityMax="([^"]*)"/.exec(i);if(!d)throw new Error("Incomplete gainmap metadata");const h=d[1];return{gainMapMin:Array.isArray(e)?e.map((e=>parseFloat(e))):[parseFloat(e),parseFloat(e),parseFloat(e)],gainMapMax:Array.isArray(t)?t.map((e=>parseFloat(e))):[parseFloat(t),parseFloat(t),parseFloat(t)],gamma:Array.isArray(r)?r.map((e=>parseFloat(e))):[parseFloat(r),parseFloat(r),parseFloat(r)],offsetSdr:Array.isArray(a)?a.map((e=>parseFloat(e))):[parseFloat(a),parseFloat(a),parseFloat(a)],offsetHdr:Array.isArray(n)?n.map((e=>parseFloat(e))):[parseFloat(n),parseFloat(n),parseFloat(n)],hdrCapacityMin:parseFloat(o),hdrCapacityMax:parseFloat(h)}}catch(a){}r=t.indexOf("<x:xmpmeta",e)}})(e);if(!t)throw new l("Gain map XMP metadata not found");const r=new g({extractFII:!0,extractNonFII:!0}),a=await r.extract(e);if(2!==a.length)throw new h("Gain map recovery image not found");return{sdr:new Uint8Array(await a[0].arrayBuffer()),gainMap:new Uint8Array(await a[1].arrayBuffer()),metadata:t}},m=e=>new Promise(((t,r)=>{const a=document.createElement("img");a.onload=()=>{t(a)},a.onerror=e=>{r(e)},a.src=URL.createObjectURL(e)}));class f extends a.aHM{constructor(e,t){super(t),e&&(this._renderer=e),this._internalLoadingManager=new a.KPJ}setRenderer(e){return this._renderer=e,this}setRenderTargetOptions(e){return this._renderTargetOptions=e,this}prepareQuadRenderer(){this._renderer||console.warn("WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.");const e=new d({gainMapMax:[1,1,1],gainMapMin:[0,0,0],gamma:[1,1,1],offsetHdr:[1,1,1],offsetSdr:[1,1,1],hdrCapacityMax:1,hdrCapacityMin:0,maxDisplayBoost:1,gainMap:new a.gPd,sdr:new a.gPd});return new o({width:16,height:16,type:a.ix0,colorSpace:a.Zr2,material:e,renderer:this._renderer,renderTargetOptions:this._renderTargetOptions})}async render(e,t,r,i){const n=i?new Blob([i],{type:"image/jpeg"}):void 0,s=new Blob([r],{type:"image/jpeg"});let o,d,h=!1;if("undefined"===typeof createImageBitmap){const e=await Promise.all([n?m(n):Promise.resolve(void 0),m(s)]);d=e[0],o=e[1],h=!0}else{const e=await Promise.all([n?createImageBitmap(n,{imageOrientation:"flipY"}):Promise.resolve(void 0),createImageBitmap(s,{imageOrientation:"flipY"})]);d=e[0],o=e[1]}const l=new a.gPd(d||new ImageData(2,2),a.UTZ,a.ghU,a.ghU,a.k6q,a.NZq,a.GWd,a.OUM,1,a.Zr2);l.flipY=h,l.needsUpdate=!0;const p=new a.gPd(o,a.UTZ,a.ghU,a.ghU,a.k6q,a.NZq,a.GWd,a.OUM,1,a.er$);p.flipY=h,p.needsUpdate=!0,e.width=o.width,e.height=o.height,e.material.gainMap=l,e.material.sdr=p,e.material.gainMapMin=t.gainMapMin,e.material.gainMapMax=t.gainMapMax,e.material.offsetHdr=t.offsetHdr,e.material.offsetSdr=t.offsetSdr,e.material.gamma=t.gamma,e.material.hdrCapacityMin=t.hdrCapacityMin,e.material.hdrCapacityMax=t.hdrCapacityMax,e.material.maxDisplayBoost=Math.pow(2,t.hdrCapacityMax),e.material.needsUpdate=!0,e.render()}}class u extends f{load(e,t,r,i){let[n,s,o]=e;const d=this.prepareQuadRenderer();let h,l,p;const g=async()=>{if(h&&l&&p){try{await this.render(d,p,h,l)}catch(e){return this.manager.itemError(n),this.manager.itemError(s),this.manager.itemError(o),"function"===typeof i&&i(e),void d.disposeOnDemandRenderer()}"function"===typeof t&&t(d),this.manager.itemEnd(n),this.manager.itemEnd(s),this.manager.itemEnd(o),d.disposeOnDemandRenderer()}};let c=!0,m=0,f=0,u=!0,v=0,w=0,y=!0,M=0,_=0;const x=()=>{if("function"===typeof r){r(new ProgressEvent("progress",{lengthComputable:c&&u&&y,loaded:f+w+_,total:m+v+M}))}};this.manager.itemStart(n),this.manager.itemStart(s),this.manager.itemStart(o);const F=new a.Y9S(this._internalLoadingManager);F.setResponseType("arraybuffer"),F.setRequestHeader(this.requestHeader),F.setPath(this.path),F.setWithCredentials(this.withCredentials),F.load(n,(async e=>{if("string"===typeof e)throw new Error("Invalid sdr buffer");h=e,await g()}),(e=>{c=e.lengthComputable,f=e.loaded,m=e.total,x()}),(e=>{this.manager.itemError(n),"function"===typeof i&&i(e)}));const T=new a.Y9S(this._internalLoadingManager);T.setResponseType("arraybuffer"),T.setRequestHeader(this.requestHeader),T.setPath(this.path),T.setWithCredentials(this.withCredentials),T.load(s,(async e=>{if("string"===typeof e)throw new Error("Invalid gainmap buffer");l=e,await g()}),(e=>{u=e.lengthComputable,w=e.loaded,v=e.total,x()}),(e=>{this.manager.itemError(s),"function"===typeof i&&i(e)}));const b=new a.Y9S(this._internalLoadingManager);return b.setRequestHeader(this.requestHeader),b.setPath(this.path),b.setWithCredentials(this.withCredentials),b.load(o,(async e=>{if("string"!==typeof e)throw new Error("Invalid metadata string");p=JSON.parse(e),await g()}),(e=>{y=e.lengthComputable,_=e.loaded,M=e.total,x()}),(e=>{this.manager.itemError(o),"function"===typeof i&&i(e)})),d}}class v extends f{load(e,t,r,i){const n=this.prepareQuadRenderer(),s=new a.Y9S(this._internalLoadingManager);return s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setPath(this.path),s.setWithCredentials(this.withCredentials),this.manager.itemStart(e),s.load(e,(async r=>{if("string"===typeof r)throw new Error("Invalid buffer, received [string], was expecting [ArrayBuffer]");const a=new Uint8Array(r);let s,o,d;try{const e=await c(a);s=e.sdr,o=e.gainMap,d=e.metadata}catch(p){if(!(p instanceof l||p instanceof h))throw p;console.warn(`Failure to reconstruct an HDR image from ${e}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`),d={gainMapMin:[0,0,0],gainMapMax:[1,1,1],gamma:[1,1,1],hdrCapacityMin:0,hdrCapacityMax:1,offsetHdr:[0,0,0],offsetSdr:[0,0,0]},s=a}try{await this.render(n,d,s,o)}catch(g){return this.manager.itemError(e),"function"===typeof i&&i(g),void n.disposeOnDemandRenderer()}"function"===typeof t&&t(n),this.manager.itemEnd(e),n.disposeOnDemandRenderer()}),r,(t=>{this.manager.itemError(e),"function"===typeof i&&i(t)})),n}}}}]);